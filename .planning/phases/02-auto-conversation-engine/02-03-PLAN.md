---
phase: 02-auto-conversation-engine
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/auto-conversation/budget-tracker.ts
  - src/auto-conversation/topic-clicker.ts
autonomous: true

must_haves:
  truths:
    - "BudgetTracker persists daily query count and resets on new day"
    - "BudgetTracker warns when approaching 80% of daily limit"
    - "TopicClicker clicks a topic pill, waits for streaming, and extracts the response"
  artifacts:
    - path: "src/auto-conversation/budget-tracker.ts"
      provides: "BudgetTracker class with persistent daily query tracking"
      exports: ["BudgetTracker"]
    - path: "src/auto-conversation/topic-clicker.ts"
      provides: "TopicClicker that clicks pills and extracts responses"
      exports: ["TopicClicker"]
  key_links:
    - from: "src/auto-conversation/topic-clicker.ts"
      to: "src/notebooklm/extractor.ts"
      via: "import ResponseExtractor from Phase 1"
      pattern: "import.*extractor"
    - from: "src/auto-conversation/topic-clicker.ts"
      to: "src/browser/wait.ts"
      via: "import waitForStreamingComplete from Phase 1"
      pattern: "import.*wait"
---

<objective>
Implement the BudgetTracker for rate limit management and TopicClicker for clicking topic pills and extracting responses.

Purpose: BudgetTracker prevents exceeding NotebookLM's 50 queries/day limit. TopicClicker is the action step — clicking a topic and getting the answer back.
Output: BudgetTracker with persistent state and TopicClicker that integrates Phase 1 extraction.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-auto-conversation-engine/02-RESEARCH.md
@.planning/phases/02-auto-conversation-engine/02-01-SUMMARY.md
@src/notebooklm/extractor.ts
@src/browser/wait.ts
@src/browser/humanize.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: BudgetTracker implementation</name>
  <files>src/auto-conversation/budget-tracker.ts</files>
  <action>
Create BudgetTracker class following the research Pattern 3 but using a simple JSON file instead of `conf` package (avoid unnecessary dependency — use `fs` to read/write a JSON file at `.msw/budget.json` relative to CWD, or a configurable path).

**Constructor:** Takes `{ dailyLimit?: number, budgetPath?: string }`. Default limit is 50. Default path is `.msw/budget.json`.

**State shape:** `BudgetState` from types.ts: `{ date: string, queriesUsed: number, limit: number }`

**Methods:**
- `canQuery(): boolean` — true if queriesUsed < limit AND date is today (auto-reset if new day)
- `remaining(): number` — limit - queriesUsed (after day check)
- `consume(): void` — increment queriesUsed, persist to disk
- `isNearLimit(): boolean` — queriesUsed / limit >= 0.8
- `getWarning(): string | null` — if isNearLimit, return "Warning: X/Y queries used today (Z remaining)". If !canQuery, return "Budget exhausted: Y/Y queries used today". Otherwise null.

**Persistence:**
- Read state from JSON file on construction (create if missing)
- Write state on every `consume()` call
- Auto-reset queriesUsed to 0 when date changes (new day)
- Ensure directory exists before writing (create `.msw/` if needed)

Do NOT install `conf` package. Use `fs.readFileSync`/`fs.writeFileSync` with `JSON.parse`/`JSON.stringify`. This is a simple budget file, not app config.
  </action>
  <verify>`npx tsc --noEmit src/auto-conversation/budget-tracker.ts` compiles</verify>
  <done>BudgetTracker tracks daily query usage, persists to disk, auto-resets on new day, warns at 80%</done>
</task>

<task type="auto">
  <name>Task 2: TopicClicker implementation</name>
  <files>src/auto-conversation/topic-clicker.ts</files>
  <action>
Create TopicClicker class that clicks a topic pill and extracts the response.

**Constructor:** Takes a Playwright `Page` instance.

**`clickAndExtract(topicText: string): Promise<string>`:**
1. Find the button element matching `topicText` on the page. Use `page.getByRole('button', { name: topicText })` or fallback to `page.locator('button').filter({ hasText: topicText })`.
2. Use `humanClick` from Phase 1 humanize utils to click the element (not raw `.click()`).
3. Wait for streaming to complete using `waitForStreamingComplete` from Phase 1.
4. Extract the response using Phase 1's `ResponseExtractor`.
5. Return the extracted response text.

**Error handling:**
- If button not found within 5 seconds, throw descriptive error: `TopicNotFound: Could not find topic pill "${topicText}"`
- If streaming times out, throw: `StreamingTimeout: Response did not complete for "${topicText}"`
- Wrap in try/catch and always return or throw — never silently fail.

Import Phase 1 utilities: `humanClick` from humanize, `waitForStreamingComplete` from wait, `ResponseExtractor` from extractor. Import `Page` from playwright.
  </action>
  <verify>`npx tsc --noEmit src/auto-conversation/topic-clicker.ts` compiles</verify>
  <done>TopicClicker clicks topic pills with humanized behavior and extracts streaming responses</done>
</task>

</tasks>

<verification>
- Both files compile without TS errors
- BudgetTracker exports class with canQuery/remaining/consume/isNearLimit/getWarning methods
- TopicClicker exports class with clickAndExtract method
- TopicClicker imports Phase 1 humanize + wait + extractor
</verification>

<success_criteria>
Rate limit tracking and topic click-and-extract automation are ready for the expansion engine.
</success_criteria>

<output>
After completion, create `.planning/phases/02-auto-conversation-engine/02-03-SUMMARY.md`
</output>
