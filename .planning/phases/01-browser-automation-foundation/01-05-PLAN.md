---
phase: 01-browser-automation-foundation
plan: 05
type: execute
wave: 3
depends_on: ["01-03", "01-04"]
files_modified:
  - src/browser/wait.ts
  - src/notebooklm/extractor.ts
autonomous: true

must_haves:
  truths:
    - "Streaming detection waits for content stability (3 checks at 1s intervals) before returning"
    - "Response extraction returns full text content only after streaming is complete"
    - "No premature extraction â€” partial/truncated content is never returned"
  artifacts:
    - path: "src/browser/wait.ts"
      provides: "Streaming completion detection via content-stability polling"
      exports: ["waitForStreamingComplete"]
    - path: "src/notebooklm/extractor.ts"
      provides: "Response extraction from NotebookLM"
      exports: ["ResponseExtractor"]
  key_links:
    - from: "src/notebooklm/extractor.ts"
      to: "src/browser/wait.ts"
      via: "calls waitForStreamingComplete before extracting text"
      pattern: "waitForStreamingComplete"
    - from: "src/notebooklm/extractor.ts"
      to: "src/browser/selectors.ts"
      via: "uses Selectors.responseContainer"
      pattern: "Selectors"
---

<objective>
Implement streaming completion detection and response extraction for NotebookLM answers.

Purpose: NotebookLM streams responses token-by-token over 5-30 seconds. Extracting too early yields truncated content. This solves BROW-06.
Output: waitForStreamingComplete utility and ResponseExtractor class.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-browser-automation-foundation/01-RESEARCH.md
@.planning/phases/01-browser-automation-foundation/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement streaming completion detection</name>
  <files>src/browser/wait.ts</files>
  <action>
  Export `waitForStreamingComplete(page: Page, selector: string, opts?)`:

  Options with defaults:
  - `pollMs`: 1000 (check every 1 second)
  - `stableCount`: 3 (content must be unchanged for 3 consecutive checks)
  - `timeoutMs`: 60000 (give up after 60 seconds)

  Implementation using `page.waitForFunction()`:
  - Pass a function to execute in browser context that:
    1. Finds element by selector
    2. Gets its textContent
    3. Compares to previous content stored in `window.__mswLastContent`
    4. Increments `window.__mswStableCount` if unchanged (and content length > 0)
    5. Resets counter if content changed
    6. Returns true when stableCount reached
  - Use `{ polling: pollMs, timeout: timeoutMs }` options

  Export `async waitForElement(page: Page, locator: Locator, timeoutMs = 10000)`:
  - Simple wrapper: `locator.waitFor({ state: 'visible', timeout: timeoutMs })`
  - Returns the locator for chaining

  After waitForStreamingComplete returns, clean up window globals:
  - `page.evaluate(() => { delete window.__mswLastContent; delete window.__mswStableCount; })`

  Add TypeScript `declare global` block for `window.__mswLastContent` and `window.__mswStableCount`.
  </action>
  <verify>`npx tsc --noEmit` passes. waitForStreamingComplete exported with correct signature.</verify>
  <done>Streaming detection uses content-stability polling, not fixed timeouts. Cleanup runs after completion.</done>
</task>

<task type="auto">
  <name>Task 2: Implement ResponseExtractor</name>
  <files>src/notebooklm/extractor.ts</files>
  <action>
  Export `ResponseExtractor` class:

  **Constructor:** Takes a Playwright `Page` instance.

  **`async extractLatestResponse(): Promise<string>`**
  1. Get response container using `Selectors.responseContainer(page)`
  2. Wait for at least one response element to be visible
  3. Get the LAST response element (most recent): `locator.last()`
  4. Get its CSS selector string for waitForStreamingComplete
  5. Call `waitForStreamingComplete(page, selectorString)`
  6. Extract `textContent` from the last response element
  7. Trim whitespace and return

  **`async extractAllResponses(): Promise<string[]>`**
  - Get all response containers, extract textContent from each
  - Return array of trimmed strings

  **`async getResponseCount(): Promise<number>`**
  - Count visible response containers

  Handle edge cases:
  - No response containers visible: return empty string / empty array
  - Timeout on streaming: catch and return whatever content exists with a warning logged to console
  </action>
  <verify>`npx tsc --noEmit` passes. ResponseExtractor exports extractLatestResponse, extractAllResponses, getResponseCount.</verify>
  <done>ResponseExtractor waits for streaming to complete before extracting, handles edge cases, uses Selectors registry</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. waitForStreamingComplete uses page.waitForFunction with content-stability (not setTimeout)
3. ResponseExtractor imports from both wait.ts and selectors.ts
</verification>

<success_criteria>
Response extraction only returns content after streaming is verified complete via 3 consecutive stable-content checks. No hard-coded timeouts for streaming detection.
</success_criteria>

<output>
After completion, create `.planning/phases/01-browser-automation-foundation/01-05-SUMMARY.md`
</output>
