---
phase: 01-browser-automation-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/browser/profile.ts
autonomous: true

must_haves:
  truths:
    - "Chrome profile directory is created at ~/.msw/chrome-profile/ and persists across process restarts"
    - "Only one browser instance can use the profile at a time (lock file prevents conflicts)"
    - "Profile directory is never the user's real Chrome profile"
  artifacts:
    - path: "src/browser/profile.ts"
      provides: "Profile directory management with single-instance locking"
      exports: ["ProfileManager"]
  key_links:
    - from: "src/browser/profile.ts"
      to: "~/.msw/chrome-profile/"
      via: "fs.mkdirSync + lock file"
      pattern: "\.msw.*chrome-profile"
---

<objective>
Implement Chrome profile directory management with single-instance locking to ensure persistent authentication and prevent concurrent access conflicts.

Purpose: NotebookLM auth persists via Chrome's cookie storage in the profile directory. This must survive restarts and prevent corruption from multiple instances.
Output: ProfileManager class that manages the dedicated profile directory lifecycle.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-browser-automation-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ProfileManager with directory management and lock file</name>
  <files>src/browser/profile.ts</files>
  <action>
  Export `ProfileManager` class:

  **Constructor:**
  - Takes optional `profileDir` (default: `path.join(os.homedir(), '.msw', 'chrome-profile')`)
  - Stores profileDir as readonly property

  **`ensureProfileDir()`:**
  - Creates profileDir with `fs.mkdirSync({ recursive: true })`
  - Returns the profileDir path

  **`acquireLock()`:**
  - Lock file path: `path.join(profileDir, '.lock')`
  - Check if lock file exists:
    - If exists, read PID from it. Check if that PID is still running (`process.kill(pid, 0)` in try/catch).
    - If PID is running: throw `Error('Another MSW instance is using this profile (PID: ${pid}). Close it first.')`
    - If PID is NOT running: stale lock, delete it and proceed
  - Write current `process.pid` to lock file
  - Register `process.on('exit')` and `process.on('SIGINT')` handlers to release lock on exit

  **`releaseLock()`:**
  - Delete lock file if it contains current process.pid
  - Called automatically on process exit

  **`isLocked()`:**
  - Returns boolean: whether a valid (non-stale) lock exists from another process

  **`getProfileDir()`:**
  - Calls `ensureProfileDir()` + `acquireLock()`
  - Returns profileDir string (ready for use as userDataDir)

  Use `path` and `os` from Node.js stdlib. No external dependencies.
  </action>
  <verify>
  `npx tsc --noEmit` passes.
  Manual check: ProfileManager creates directory, writes lock file with PID, releases on close.
  </verify>
  <done>ProfileManager creates ~/.msw/chrome-profile/, acquires lock with PID, detects stale locks, releases on process exit</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. src/browser/profile.ts exports ProfileManager
3. Lock file mechanism prevents two instances from using same profile
</verification>

<success_criteria>
ProfileManager handles profile directory lifecycle. Lock prevents concurrent access. Stale locks from crashed processes are cleaned up automatically.
</success_criteria>

<output>
After completion, create `.planning/phases/01-browser-automation-foundation/01-02-SUMMARY.md`
</output>
