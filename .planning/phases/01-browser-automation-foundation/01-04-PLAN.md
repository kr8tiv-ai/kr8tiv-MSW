---
phase: 01-browser-automation-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/browser/selectors.ts
  - src/browser/humanize.ts
autonomous: true

must_haves:
  truths:
    - "All NotebookLM UI interactions use semantic locators (getByRole, getByText) as primary selectors"
    - "Selector registry is a single source of truth, updatable in one place"
    - "Humanized delays add randomized wait between all UI actions"
  artifacts:
    - path: "src/browser/selectors.ts"
      provides: "Semantic selector registry for NotebookLM UI elements"
      exports: ["Selectors", "getSelector"]
    - path: "src/browser/humanize.ts"
      provides: "Humanized interaction utilities"
      exports: ["randomDelay", "humanType", "humanClick"]
  key_links:
    - from: "src/browser/selectors.ts"
      to: "playwright"
      via: "Page.getByRole, Page.getByText locator methods"
      pattern: "getByRole|getByText"
---

<objective>
Build the semantic selector registry for NotebookLM UI elements and humanized interaction utilities that add realistic delays to all automation actions.

Purpose: Selectors must survive NotebookLM UI deploys (no brittle CSS classes). Humanization prevents bot detection.
Output: Selector registry and humanize utilities ready for use by navigator and extractor.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-browser-automation-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement semantic selector registry</name>
  <files>src/browser/selectors.ts</files>
  <action>
  Export `Selectors` object — a registry of factory functions that take a Playwright `Page` and return `Locator`:

  ```typescript
  export const Selectors = {
    chatInput: (page: Page) => page.getByRole('textbox', { name: /ask|type/i }),
    sendButton: (page: Page) => page.getByRole('button', { name: /send|submit/i }),
    topicPills: (page: Page) => page.getByRole('button').filter({ hasText: /.{4,80}/ }),
    responseContainer: (page: Page) => page.locator('[data-message-author="assistant"]'),
    signInButton: (page: Page) => page.getByRole('button', { name: /sign in/i }),
  };
  ```

  Export `getSelector(name: keyof typeof Selectors, page: Page)` helper function.

  Export `async validateSelectors(page: Page): Promise<{ valid: boolean; failures: string[] }>`:
  - Check each critical selector (chatInput, sendButton) for visibility with 5s timeout
  - Return list of failures
  - Non-critical selectors (topicPills, responseContainer) logged as warnings but don't fail validation

  IMPORTANT: These selectors are best guesses from research. The actual NotebookLM accessibility labels need live inspection. Include a comment noting selectors may need adjustment after first manual test.
  </action>
  <verify>`npx tsc --noEmit` passes. Selectors object exports all documented locator factories.</verify>
  <done>Selector registry uses getByRole/getByText as primary locators, has validation function, updatable in one place</done>
</task>

<task type="auto">
  <name>Task 2: Implement humanized interaction utilities</name>
  <files>src/browser/humanize.ts</files>
  <action>
  Export humanization utilities:

  **`randomDelay(minMs = 100, maxMs = 400): Promise<void>`**
  - Random wait between min and max milliseconds

  **`async humanType(locator: Locator, text: string, opts?: { minDelay?: number, maxDelay?: number })`**
  - Type each character with random delay between minDelay (50ms) and maxDelay (200ms)
  - Use `locator.pressSequentially()` with calculated per-character delay
  - Add small pause (200-500ms) after typing completes

  **`async humanClick(locator: Locator, opts?: { preDelay?: boolean })`**
  - If preDelay (default true): wait randomDelay before clicking
  - Click with `locator.click()`
  - Wait randomDelay after clicking

  **`async humanScroll(page: Page, direction: 'up' | 'down', amount?: number)`**
  - Scroll with randomized amount (default 100-300px)
  - Add delay after scroll

  All delays configurable but with sensible defaults matching human interaction patterns.
  No external dependencies — pure utility module.
  </action>
  <verify>`npx tsc --noEmit` passes. All 4 functions exported.</verify>
  <done>Humanize module provides randomDelay, humanType, humanClick, humanScroll with configurable timing</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Selectors use getByRole/getByText (grep confirms no hardcoded CSS class selectors)
3. Humanize functions have randomized delays (not fixed waits)
</verification>

<success_criteria>
Selector registry centralizes all NotebookLM UI element lookups using semantic locators. Humanize utilities ready to wrap all user-facing interactions.
</success_criteria>

<output>
After completion, create `.planning/phases/01-browser-automation-foundation/01-04-SUMMARY.md`
</output>
