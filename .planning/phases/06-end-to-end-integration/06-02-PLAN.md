---
phase: 06-end-to-end-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config/schema.ts
  - src/config/validator.ts
  - src/pipeline/health.ts
  - src/pipeline/state.ts
autonomous: true

must_haves:
  truths:
    - "Config validation rejects invalid notebookUrl, relevanceThreshold out of range, bad maxDepth"
    - "Health check reports status of browser, Ollama, and git subsystems"
    - "Pipeline state persists to .msw/state.json and restores on restart"
  artifacts:
    - path: "src/config/schema.ts"
      provides: "Zod schema for MSW configuration"
      contains: "MswConfigSchema"
    - path: "src/config/validator.ts"
      provides: "Config loading and validation"
      exports: ["loadConfig", "validateConfig"]
    - path: "src/pipeline/health.ts"
      provides: "Health check for all subsystems"
      exports: ["checkHealth"]
    - path: "src/pipeline/state.ts"
      provides: "Pipeline state persistence and crash recovery"
      exports: ["saveCheckpoint", "restoreCheckpoint"]
  key_links:
    - from: "src/config/validator.ts"
      to: "src/config/schema.ts"
      via: "imports MswConfigSchema for validation"
      pattern: "MswConfigSchema"
    - from: "src/pipeline/state.ts"
      to: ".msw/state.json"
      via: "read/write JSON"
      pattern: "state\\.json"
---

<objective>
Create configuration validation, health checks, and crash recovery state persistence.

Purpose: Production hardening requires validating config before pipeline runs, checking subsystem health for graceful degradation, and persisting state for crash recovery.
Output: Config schema + validator, health check module, state persistence module.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-end-to-end-integration/06-RESEARCH.md
@src/mcp/tools/msw-init.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config schema and validator</name>
  <files>src/config/schema.ts, src/config/validator.ts</files>
  <action>
Create src/config/schema.ts:
- Define MswConfigSchema using zod (already in deps):
  - notebookUrl: z.string().url()
  - profileDir: z.string().optional()
  - relevanceThreshold: z.number().min(0).max(100).default(30)
  - maxDepth: z.number().min(1).max(10).default(5)
  - maxQueriesPerDay: z.number().default(50)
  - version: z.string().optional()
- Export the schema and inferred MswConfig type

Create src/config/validator.ts:
- loadConfig(projectDir: string): reads .msw/config.json, parses with MswConfigSchema, returns validated config or throws with clear error messages
- validateConfig(raw: unknown): pure validation, returns { success, data, errors }
  </action>
  <verify>Run `npm run check` to confirm types are correct.</verify>
  <done>Config schema validates all fields with sensible defaults; loadConfig reads and validates .msw/config.json.</done>
</task>

<task type="auto">
  <name>Task 2: Health checks and pipeline state persistence</name>
  <files>src/pipeline/health.ts, src/pipeline/state.ts</files>
  <action>
Create src/pipeline/health.ts:
- Define HealthCheck interface: { component: string; healthy: boolean; degraded?: string }
- checkHealth(): Promise<HealthCheck[]> that checks:
  - Browser: try importing playwright, check if chromium executable exists
  - Ollama: try fetch to localhost:11434/api/tags (with 2s timeout, catch = unhealthy)
  - Git: try `which git` or check simple-git availability
- Each check returns healthy/unhealthy with degraded message explaining what's lost

Create src/pipeline/state.ts:
- Define PipelineState interface per research doc: sessionId, phase, pendingQueries, completedQA, lastCheckpoint
- saveCheckpoint(projectDir, state): writes to .msw/state.json atomically (write to .tmp then rename)
- restoreCheckpoint(projectDir): reads .msw/state.json, returns PipelineState | null
- clearCheckpoint(projectDir): removes state file after successful completion
  </action>
  <verify>Run `npm run check` to confirm types are correct.</verify>
  <done>Health check reports status of 3 subsystems; state persists to disk and restores correctly.</done>
</task>

</tasks>

<verification>
- `npm run check` passes
- `npm run build` succeeds
</verification>

<success_criteria>
Config validation catches bad input with clear errors. Health checks report degraded capabilities. State file round-trips correctly.
</success_criteria>

<output>
After completion, create `.planning/phases/06-end-to-end-integration/06-02-SUMMARY.md`
</output>
