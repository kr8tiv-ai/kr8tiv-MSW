---
phase: 07-automated-testing-suite
plan: 04
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - tests/integration/auth-flow.test.ts
  - tests/integration/backup-restore.test.ts
autonomous: true

must_haves:
  truths:
    - "Auth flow persists session across crash and restores"
    - "Backup-restore flow handles corruption and rollback"
  artifacts:
    - path: "tests/integration/auth-flow.test.ts"
      provides: "Auth flow integration test"
      min_lines: 60
    - path: "tests/integration/backup-restore.test.ts"
      provides: "Backup-restore flow integration test"
      min_lines: 60
  key_links:
    - from: "tests/integration/auth-flow.test.ts"
      to: "src/auth/authenticator.ts"
      via: "real implementation"
      pattern: "new Authenticator"
    - from: "tests/integration/backup-restore.test.ts"
      to: "src/backup/manager.ts"
      via: "real implementation"
      pattern: "new BackupManager"
---

<objective>
Create integration tests validating multi-component workflows (auth flow, backup-restore flow) with real implementations but mocked browser.

**Purpose:** Verify that modules work together correctly in realistic scenarios (login -> persist -> restore, save -> corrupt -> recover) before E2E testing. Integration tests catch wiring issues that unit tests miss.

**Output:** Two integration test suites covering auth session persistence across crashes and backup corruption recovery.
</objective>

<execution_context>
@C:\Users\lucid\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\lucid\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-automated-testing-suite/07-RESEARCH.md
@.planning/phases/07-automated-testing-suite/07-01-SUMMARY.md
@.planning/phases/07-automated-testing-suite/07-02-SUMMARY.md

# Modules to integrate
@src/auth/authenticator.ts
@src/backup/manager.ts
@src/config/manager.ts

# Test infrastructure
@tests/setup.ts
@tests/mocks/browser-mocks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth flow integration test</name>
  <files>tests/integration/auth-flow.test.ts</files>
  <action>
Create `tests/integration/auth-flow.test.ts`:

```typescript
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { Authenticator } from "../../src/auth/authenticator.js";
import { BackupManager } from "../../src/backup/manager.js";
import { createTestDir, cleanupTestDir } from "../setup.js";
import { createMockPage } from "../mocks/browser-mocks.js";
import type { Cookie } from "playwright";

describe("Auth flow integration", () => {
  let testDir: string;

  beforeEach(() => {
    testDir = createTestDir("auth-flow-test");
  });

  afterEach(() => {
    cleanupTestDir(testDir);
  });

  it("persists auth state and restores after crash", async () => {
    // 1. Simulate login - user has valid session
    const validCookies: Cookie[] = [
      {
        name: "SID",
        value: "session-abc123",
        domain: ".google.com",
        path: "/",
        expires: -1,
        httpOnly: false,
        secure: true,
        sameSite: "Lax",
      },
      {
        name: "HSID",
        value: "host-xyz789",
        domain: ".google.com",
        path: "/",
        expires: -1,
        httpOnly: false,
        secure: true,
        sameSite: "Lax",
      },
    ];

    const mockPage = createMockPage({ cookies: validCookies });
    const auth1 = new Authenticator(mockPage);

    const loginResult = await auth1.validateSession();
    expect(loginResult.authenticated).toBe(true);
    expect(loginResult.sessionId).toBe("session-abc123");

    // 2. Persist auth state to backup
    const backup = new BackupManager(testDir);
    await backup.saveState({
      sessionId: loginResult.sessionId,
      cookies: validCookies,
      timestamp: Date.now(),
    });

    const backupExists = await backup.exists();
    expect(backupExists).toBe(true);

    // 3. Simulate crash + restore
    const restoreResult = await backup.restoreState();
    expect(restoreResult.success).toBe(true);
    expect(restoreResult.state.sessionId).toBe("session-abc123");
    expect(restoreResult.state.cookies).toHaveLength(2);

    // 4. Validate restored session works
    const restoredPage = createMockPage({
      cookies: restoreResult.state.cookies,
    });
    const auth2 = new Authenticator(restoredPage);

    const validateResult = await auth2.validateSession();
    expect(validateResult.authenticated).toBe(true);
    expect(validateResult.sessionId).toBe("session-abc123");
  });

  it("handles session expiry during restore", async () => {
    // Persist expired session
    const expiredCookies: Cookie[] = [
      {
        name: "SID",
        value: "expired-token",
        domain: ".google.com",
        path: "/",
        expires: Date.now() - 86400_000, // 1 day ago
        httpOnly: false,
        secure: true,
        sameSite: "Lax",
      },
    ];

    const backup = new BackupManager(testDir);
    await backup.saveState({
      sessionId: "expired-token",
      cookies: expiredCookies,
      timestamp: Date.now() - 86400_000,
    });

    // Restore and validate
    const restoreResult = await backup.restoreState();
    expect(restoreResult.success).toBe(true);

    const restoredPage = createMockPage({
      cookies: restoreResult.state.cookies,
    });
    const auth = new Authenticator(restoredPage);

    const validateResult = await auth.validateSession();
    expect(validateResult.authenticated).toBe(false);
    expect(validateResult.reason).toContain("expired");
  });

  it("detects logout between backups", async () => {
    const validCookies: Cookie[] = [
      {
        name: "SID",
        value: "session-valid",
        domain: ".google.com",
        path: "/",
        expires: -1,
        httpOnly: false,
        secure: true,
        sameSite: "Lax",
      },
    ];

    // First backup - valid session
    const backup = new BackupManager(testDir);
    await backup.saveState({
      sessionId: "session-valid",
      cookies: validCookies,
      timestamp: Date.now(),
    });

    // Simulate logout - cookies cleared
    const loggedOutPage = createMockPage({ cookies: [] });
    const auth = new Authenticator(loggedOutPage);

    const checkResult = await auth.validateSession();
    expect(checkResult.authenticated).toBe(false);
    expect(checkResult.reason).toContain("logout");

    // New backup reflects logout state
    await backup.saveState({
      sessionId: null,
      cookies: [],
      timestamp: Date.now(),
    });

    const restoreResult = await backup.restoreState();
    expect(restoreResult.success).toBe(true);
    expect(restoreResult.state.sessionId).toBeNull();
  });
});
```

**Test coverage:**
- Login -> persist -> crash -> restore -> validate (happy path)
- Session expiry detected during restore
- Logout state persisted and restored
  </action>
  <verify>
```bash
npm run test -- tests/integration/auth-flow.test.ts
```
All auth flow integration tests pass.
  </verify>
  <done>Auth flow integration test validates session persistence, crash recovery, expiry handling, and logout detection</done>
</task>

<task type="auto">
  <name>Task 2: Create backup-restore integration test</name>
  <files>tests/integration/backup-restore.test.ts</files>
  <action>
Create `tests/integration/backup-restore.test.ts`:

```typescript
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { BackupManager } from "../../src/backup/manager.js";
import { ConfigManager } from "../../src/config/manager.js";
import { createTestDir, cleanupTestDir } from "../setup.js";
import fs from "node:fs";
import path from "node:path";

describe("Backup-restore flow integration", () => {
  let testDir: string;
  let backup: BackupManager;
  let config: ConfigManager;

  beforeEach(() => {
    testDir = createTestDir("backup-restore-test");
    backup = new BackupManager(testDir);
    config = new ConfigManager(testDir);
  });

  afterEach(() => {
    cleanupTestDir(testDir);
  });

  it("saves state, corrupts backup, recovers from previous", async () => {
    // 1. Save initial state
    await backup.saveState({
      version: 1,
      data: "first backup",
      timestamp: Date.now(),
    });

    const backup1Path = await backup.getLatestPath();
    expect(fs.existsSync(backup1Path)).toBe(true);

    // 2. Save second state
    await backup.saveState({
      version: 2,
      data: "second backup",
      timestamp: Date.now(),
    });

    const backup2Path = await backup.getLatestPath();
    expect(backup2Path).not.toBe(backup1Path);

    // 3. Corrupt latest backup
    fs.writeFileSync(backup2Path, "corrupted-json{{{");

    // 4. Attempt restore - should detect corruption
    const restoreResult = await backup.restoreState();
    expect(restoreResult.success).toBe(false);
    expect(restoreResult.error).toContain("corrupt");

    // 5. Rollback to previous backup
    const rollbackResult = await backup.rollback();
    expect(rollbackResult.success).toBe(true);
    expect(rollbackResult.state.version).toBe(1);
    expect(rollbackResult.state.data).toBe("first backup");
  });

  it("handles complete backup directory corruption", async () => {
    // Save valid state
    await backup.saveState({ valid: true });

    // Corrupt entire backup directory
    const backupDir = path.join(testDir, ".msw", "backups");
    fs.rmSync(backupDir, { recursive: true, force: true });

    // Restore should fail gracefully
    const result = await backup.restoreState();
    expect(result.success).toBe(false);
    expect(result.error).toContain("not found");

    // Rollback should also fail gracefully
    const rollbackResult = await backup.rollback();
    expect(rollbackResult.success).toBe(false);
  });

  it("integrates backup with config changes", async () => {
    // 1. Create initial config
    await config.save({
      version: "0.1.0",
      notebookUrl: "https://notebooklm.google.com/notebook/initial",
      relevanceThreshold: 30,
    });

    // 2. Backup state including config
    const configData = await config.load();
    await backup.saveState({
      config: configData,
      timestamp: Date.now(),
    });

    // 3. Update config
    await config.save({
      version: "0.1.0",
      notebookUrl: "https://notebooklm.google.com/notebook/updated",
      relevanceThreshold: 40,
    });

    // 4. Simulate crash - restore from backup
    const restoreResult = await backup.restoreState();
    expect(restoreResult.success).toBe(true);

    // 5. Verify old config can be retrieved
    expect(restoreResult.state.config.notebookUrl).toContain("initial");
    expect(restoreResult.state.config.relevanceThreshold).toBe(30);
  });

  it("handles rapid backup sequences without data loss", async () => {
    // Simulate rapid successive backups (stress test)
    const backupPromises = [];

    for (let i = 0; i < 10; i++) {
      backupPromises.push(
        backup.saveState({
          iteration: i,
          timestamp: Date.now(),
        })
      );
    }

    await Promise.all(backupPromises);

    // Verify latest backup is intact
    const restoreResult = await backup.restoreState();
    expect(restoreResult.success).toBe(true);
    expect(restoreResult.state.iteration).toBeGreaterThanOrEqual(0);
    expect(restoreResult.state.iteration).toBeLessThan(10);

    // Verify multiple backups exist
    const backupCount = await backup.count();
    expect(backupCount).toBeGreaterThan(1);
  });

  it("cleans up old backups beyond retention limit", async () => {
    // Create many backups
    for (let i = 0; i < 15; i++) {
      await backup.saveState({ version: i });
    }

    // Trigger cleanup (if implemented)
    await backup.cleanup({ retainCount: 5 });

    // Verify only recent backups remain
    const backupCount = await backup.count();
    expect(backupCount).toBeLessThanOrEqual(5);

    // Verify we can still restore latest
    const restoreResult = await backup.restoreState();
    expect(restoreResult.success).toBe(true);
    expect(restoreResult.state.version).toBeGreaterThanOrEqual(10);
  });
});
```

**Test coverage:**
- Save -> corrupt -> recover from previous backup
- Complete backup directory corruption handled gracefully
- Backup integrated with config changes
- Rapid backup sequences without data loss
- Old backup cleanup with retention limit
  </action>
  <verify>
```bash
npm run test -- tests/integration/backup-restore.test.ts
npm run test:coverage -- tests/integration/
```
All backup-restore integration tests pass, integration coverage at 75%+.

**Key links verified:**
- Confirm backup.saveState with config data + restore retrieves old config (test case "integrates backup with config changes" validates BackupManager-ConfigManager wiring)
  </verify>
  <done>Backup-restore integration test validates corruption recovery, config integration (BackupManager saves config via ConfigManager.load, restores old values), rapid backups, and cleanup</done>
</task>

</tasks>

<verification>
**Integration test checks:**
1. Run `npm run test -- tests/integration/` - all tests pass
2. Run `npm run test:coverage -- tests/integration/` - coverage at 75%+
3. Verify integration tests use real implementations (not mocked internals)
4. Check test execution time (< 30 seconds for all integration tests)

**Flow validation:**
- Auth flow: login -> persist -> crash -> restore -> validate
- Backup-restore flow: save -> corrupt -> recover
</verification>

<success_criteria>
**Integration tests are complete when:**
1. Auth flow test validates session persistence across crash
2. Auth flow test handles expiry and logout scenarios
3. Backup-restore test validates corruption detection and rollback
4. Backup-restore test handles rapid backups without data loss
5. Integration tests use real module implementations (Authenticator, BackupManager, ConfigManager)
6. All integration tests pass consistently
7. Integration test suite runs in < 30 seconds
</success_criteria>

<output>
After completion, create `.planning/phases/07-automated-testing-suite/07-04-SUMMARY.md` with:
- Integration test suites created (auth-flow, backup-restore)
- Test scenarios covered (crash recovery, corruption, expiry, logout)
- Integration coverage achieved (% across auth, backup, config modules)
- Test execution time (target: < 30s)
- Next steps: E2E tests with full MCP server (07-05)
</output>
