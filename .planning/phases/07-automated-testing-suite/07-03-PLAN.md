---
phase: 07-automated-testing-suite
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - tests/mocks/notebooklm-ui.html
  - tests/helpers/mock-notebooklm.ts
  - tests/unit/browser/selectors.test.ts
autonomous: true

must_haves:
  truths:
    - "Mock NotebookLM UI serves via Express on random port"
    - "Mock UI mimics real NotebookLM structure for selector testing"
    - "Selector tests validate semantic/accessibility patterns"
  artifacts:
    - path: "tests/mocks/notebooklm-ui.html"
      provides: "Static HTML mimicking NotebookLM structure"
      contains: "role=\"textbox\""
      min_lines: 50
    - path: "tests/helpers/mock-notebooklm.ts"
      provides: "Express server for mock UI"
      exports: ["startMockNotebookLM"]
    - path: "tests/unit/browser/selectors.test.ts"
      provides: "Selector validation tests"
      min_lines: 40
  key_links:
    - from: "tests/helpers/mock-notebooklm.ts"
      to: "tests/mocks/notebooklm-ui.html"
      via: "express.static or res.sendFile"
      pattern: "sendFile.*notebooklm-ui\\.html"
    - from: "tests/unit/browser/selectors.test.ts"
      to: "src/browser/selectors.ts"
      via: "import and validate"
      pattern: "import.*SELECTORS"
---

<objective>
Build mock NotebookLM UI and selector test fixtures to enable deterministic testing of browser selectors without live NotebookLM dependency.

**Purpose:** Provides a stable, controllable NotebookLM-like environment for testing semantic selectors, topic detection, and response extraction without risk of external rate limits or UI changes breaking tests.

**Output:** Mock NotebookLM HTML page served via Express, helper to spawn mock server, and selector validation tests that run against the mock UI.
</objective>

<execution_context>
@C:\Users\lucid\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\lucid\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-automated-testing-suite/07-RESEARCH.md
@.planning/phases/07-automated-testing-suite/07-01-SUMMARY.md

# Selector implementation
@src/browser/selectors.ts

# Test infrastructure
@vitest.config.ts
@tests/setup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mock NotebookLM UI HTML</name>
  <files>tests/mocks/notebooklm-ui.html</files>
  <action>
Create `tests/mocks/notebooklm-ui.html` mimicking NotebookLM structure:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Mock NotebookLM</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
        max-width: 800px;
        margin: 0 auto;
      }
      .chat-input {
        width: 100%;
        padding: 10px;
        margin: 10px 0;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      .send-button {
        padding: 10px 20px;
        background: #1a73e8;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      .suggested-topics {
        margin: 20px 0;
      }
      .topic-pill {
        display: inline-block;
        margin: 5px;
        padding: 10px 15px;
        border: 1px solid #ccc;
        border-radius: 20px;
        cursor: pointer;
        background: white;
      }
      .topic-pill:hover {
        background: #f5f5f5;
      }
      .response {
        padding: 15px;
        background: #f5f5f5;
        margin: 10px 0;
        border-radius: 8px;
      }
      .citation {
        font-size: 0.9em;
        color: #666;
        margin-top: 8px;
      }
    </style>
  </head>
  <body>
    <h1>Mock NotebookLM</h1>

    <!-- Chat input (mimics real NotebookLM structure) -->
    <textarea
      role="textbox"
      aria-label="Ask about your notes"
      class="chat-input"
      id="chat-input"
      rows="3"></textarea>
    <button
      role="button"
      aria-label="Send message"
      class="send-button"
      onclick="handleSend()">Send</button>

    <!-- Suggested topics (mimics topic pills) -->
    <div role="list" aria-label="Suggested topics" class="suggested-topics">
      <button
        role="button"
        data-topic="authentication"
        class="topic-pill"
        onclick="handleTopicClick('authentication')">
        Learn about authentication
      </button>
      <button
        role="button"
        data-topic="testing"
        class="topic-pill"
        onclick="handleTopicClick('testing')">
        Learn about testing patterns
      </button>
      <button
        role="button"
        data-topic="browser"
        class="topic-pill"
        onclick="handleTopicClick('browser')">
        Learn about browser automation
      </button>
    </div>

    <!-- Response container -->
    <div id="responses" aria-live="polite"></div>

    <script>
      const responses = {
        authentication: "Authentication in MSW uses persistent Chrome profiles to maintain Google session cookies across restarts.",
        testing: "Testing follows a three-tier approach: unit tests with mocked dependencies, integration tests with real components, and E2E tests with the full system.",
        browser: "Browser automation uses Playwright with stealth plugins to avoid bot detection and humanized delays for natural interaction patterns.",
      };

      const citations = {
        authentication: ["auth.md", "browser.md"],
        testing: ["testing.md", "vitest.config.ts"],
        browser: ["browser.md", "stealth.md"],
      };

      function handleTopicClick(topic) {
        const responseDiv = document.createElement('div');
        responseDiv.className = 'response';
        responseDiv.setAttribute('data-message-author', 'assistant');
        responseDiv.setAttribute('data-streaming', 'true');

        const answerText = responses[topic] || 'No response available for this topic.';
        const sourceCitations = citations[topic] || [];

        responseDiv.innerHTML = `
          <p>${answerText}</p>
          <div class="citation">
            ${sourceCitations.map(src => `[Source: ${src}]`).join(', ')}
          </div>
        `;

        document.getElementById('responses').appendChild(responseDiv);

        // Simulate streaming completion (for wait detection tests)
        setTimeout(() => {
          responseDiv.setAttribute('data-streaming', 'false');
        }, 200);
      }

      function handleSend() {
        const input = document.getElementById('chat-input');
        const query = input.value.toLowerCase();

        // Match query to topic
        if (query.includes('auth')) {
          handleTopicClick('authentication');
        } else if (query.includes('test')) {
          handleTopicClick('testing');
        } else if (query.includes('browser')) {
          handleTopicClick('browser');
        } else {
          const responseDiv = document.createElement('div');
          responseDiv.className = 'response';
          responseDiv.setAttribute('data-message-author', 'assistant');
          responseDiv.setAttribute('data-streaming', 'false');
          responseDiv.innerHTML = '<p>I can help with authentication, testing, and browser automation topics.</p>';
          document.getElementById('responses').appendChild(responseDiv);
        }

        input.value = '';
      }
    </script>
  </body>
</html>
```

**Key features:**
- Semantic selectors (role="textbox", aria-label, data-topic)
- Topic pills with click handlers
- Response structure with streaming simulation
- Citations matching real NotebookLM format
  </action>
  <verify>
```bash
cat tests/mocks/notebooklm-ui.html | grep -c "role=\""
```
Should find multiple role attributes (textbox, button, list).
  </verify>
  <done>Mock NotebookLM UI HTML exists with semantic structure matching real NotebookLM</done>
</task>

<task type="auto">
  <name>Task 2: Create mock server helper</name>
  <files>tests/helpers/mock-notebooklm.ts</files>
  <action>
Create `tests/helpers/mock-notebooklm.ts`:

```typescript
import express from "express";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import type { Server } from "node:http";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export interface MockNotebookLMServer {
  url: string;
  port: number;
  close: () => Promise<void>;
}

export async function startMockNotebookLM(options?: {
  port?: number;
  delayMs?: number; // Simulate network latency
}): Promise<MockNotebookLMServer> {
  const app = express();
  const delay = options?.delayMs ?? 0;

  // Middleware to simulate network latency
  if (delay > 0) {
    app.use((req, res, next) => {
      setTimeout(next, delay);
    });
  }

  // Serve mock UI HTML
  app.get("/notebook/:id", (req, res) => {
    const htmlPath = path.join(__dirname, "../mocks/notebooklm-ui.html");
    res.sendFile(htmlPath);
  });

  // Optional: API endpoint for programmatic testing
  app.post("/api/query", express.json(), (req, res) => {
    const { query } = req.body;
    const mockResponse = {
      answer: `Mock response to: ${query}`,
      citations: ["test.md"],
      suggestedTopics: ["Related topic 1", "Related topic 2"],
    };
    res.json(mockResponse);
  });

  const port = options?.port ?? 0; // Random port if not specified
  const server: Server = await new Promise((resolve) => {
    const s = app.listen(port, () => resolve(s));
  });

  const actualPort = (server.address() as any).port;
  const url = `http://localhost:${actualPort}/notebook/mock-123`;

  return {
    url,
    port: actualPort,
    close: async () => {
      return new Promise((resolve, reject) => {
        server.close((err) => {
          if (err) reject(err);
          else resolve();
        });
      });
    },
  };
}
```

**Features:**
- Express server serving mock HTML
- Random port allocation (avoids conflicts)
- Optional network delay simulation
- Clean shutdown support
  </action>
  <verify>
```bash
# Check imports
grep -E "(express|Server)" tests/helpers/mock-notebooklm.ts
```
Should find express import and Server type.
  </verify>
  <done>Mock server helper exists with startMockNotebookLM export that returns server URL and close function</done>
</task>

<task type="auto">
  <name>Task 3: Create selector validation tests</name>
  <files>tests/unit/browser/selectors.test.ts</files>
  <action>
Create `tests/unit/browser/selectors.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll } from "vitest";
import { chromium, type Browser, type Page } from "playwright";
import { startMockNotebookLM, type MockNotebookLMServer } from "../../helpers/mock-notebooklm.js";
import { SELECTORS } from "../../../src/browser/selectors.js";

describe("NotebookLM selectors", () => {
  let browser: Browser;
  let page: Page;
  let mockServer: MockNotebookLMServer;

  beforeAll(async () => {
    // Start mock NotebookLM server
    mockServer = await startMockNotebookLM();

    // Launch real browser to test selectors
    browser = await chromium.launch({ headless: true });
    page = await browser.newPage();
    await page.goto(mockServer.url);
  }, 15000); // 15s timeout for browser launch

  afterAll(async () => {
    await page?.close();
    await browser?.close();
    await mockServer?.close();
  });

  describe("SELECTORS export", () => {
    it("exports all expected selector patterns", () => {
      // Verify SELECTORS export exists and contains expected patterns
      expect(SELECTORS).toBeDefined();
      expect(SELECTORS.chatInput).toBeDefined();
      expect(SELECTORS.sendButton).toBeDefined();
      expect(SELECTORS.topicPills).toBeDefined();
      expect(SELECTORS.responseContainer).toBeDefined();
    });
  });

  describe("chatInput selector", () => {
    it("finds chat input using semantic selector", async () => {
      const input = page.locator(SELECTORS.chatInput);

      await expect(input).toBeVisible();
      const ariaLabel = await input.getAttribute("aria-label");
      expect(ariaLabel?.toLowerCase()).toContain("ask");
    });

    it("chat input is editable", async () => {
      const input = page.locator(SELECTORS.chatInput);
      await input.fill("test query");

      const value = await input.inputValue();
      expect(value).toBe("test query");
    });
  });

  describe("sendButton selector", () => {
    it("finds send button using semantic selector", async () => {
      const button = page.locator(SELECTORS.sendButton);

      await expect(button).toBeVisible();
      const ariaLabel = await button.getAttribute("aria-label");
      expect(ariaLabel?.toLowerCase()).toContain("send");
    });

    it("send button is clickable", async () => {
      const button = page.locator(SELECTORS.sendButton);

      await expect(button).toBeEnabled();
    });
  });

  describe("topicPills selector", () => {
    it("finds all topic pills using role and data attributes", async () => {
      const pills = page.locator(SELECTORS.topicPills);
      const count = await pills.count();

      expect(count).toBeGreaterThanOrEqual(3); // Mock has 3 topics
    });

    it("topic pills have data-topic attributes", async () => {
      const firstPill = page.locator(SELECTORS.topicPills).first();
      const topic = await firstPill.getAttribute("data-topic");

      expect(topic).toBeDefined();
      expect(topic).toMatch(/authentication|testing|browser/);
    });

    it("clicking topic pill generates response", async () => {
      const firstPill = page.locator(SELECTORS.topicPills).first();
      await firstPill.click();

      // Wait for response to appear
      await page.waitForSelector('[data-message-author="assistant"]', {
        timeout: 2000,
      });

      const responses = page.locator('[data-message-author="assistant"]');
      const count = await responses.count();
      expect(count).toBeGreaterThanOrEqual(1);
    });
  });

  describe("responseContainer selector", () => {
    it("finds response after topic click", async () => {
      const pill = page.locator(SELECTORS.topicPills).first();
      await pill.click();

      const response = page.locator(SELECTORS.responseContainer).first();
      await expect(response).toBeVisible();
    });

    it("response contains text content", async () => {
      const pill = page.locator(SELECTORS.topicPills).first();
      await pill.click();

      await page.waitForSelector('[data-message-author="assistant"]');
      const response = page.locator(SELECTORS.responseContainer).first();
      const text = await response.textContent();

      expect(text).toBeTruthy();
      expect(text!.length).toBeGreaterThan(10);
    });
  });

  describe("streamingComplete selector", () => {
    it("detects streaming completion", async () => {
      const pill = page.locator(SELECTORS.topicPills).first();
      await pill.click();

      // Wait for streaming to complete (mock sets data-streaming="false" after 200ms)
      await page.waitForSelector('[data-streaming="false"]', {
        timeout: 3000,
      });

      const completed = page.locator('[data-streaming="false"]');
      const count = await completed.count();
      expect(count).toBeGreaterThanOrEqual(1);
    });
  });
});
```

**Test coverage:**
- Chat input semantic selector works
- Send button semantic selector works
- Topic pills found via role and data attributes
- Response extraction after topic click
- Streaming completion detection
  </action>
  <verify>
```bash
npm run test -- tests/unit/browser/selectors.test.ts
```
All selector tests pass against mock UI.
  </verify>
  <done>Selector validation tests exist and pass against mock NotebookLM UI, confirming semantic selectors work</done>
</task>

</tasks>

<verification>
**Mock UI checks:**
1. Visit mock UI manually: Start server and open in browser to confirm structure
2. Run selector tests: `npm run test -- tests/unit/browser/selectors.test.ts`
3. Verify all selectors find elements (no timeouts or "element not found" errors)
4. Check test output shows topic click -> response flow works

**Determinism:**
- Run tests 3 times - should get same results each time
- Mock UI does not depend on external services
</verification>

<success_criteria>
**Mock UI is complete when:**
1. Mock NotebookLM HTML mimics real structure (role, aria-label, data-topic attributes)
2. Mock server starts on random port and serves HTML via Express
3. Selector tests validate all critical selectors (chatInput, sendButton, topicPills, responseContainer)
4. Topic click flow works end-to-end (click -> response appears -> streaming completes)
5. Tests are deterministic (no flakiness, same results every run)
6. Mock server can be reused across test suites (startMockNotebookLM helper)
</success_criteria>

<output>
After completion, create `.planning/phases/07-automated-testing-suite/07-03-SUMMARY.md` with:
- Mock UI structure (HTML elements, semantic attributes)
- Mock server implementation (Express, random port allocation)
- Selector tests created (count, which selectors validated)
- Test execution results (all pass, deterministic)
- Next steps: Integration tests using mock UI (07-04)
</output>
