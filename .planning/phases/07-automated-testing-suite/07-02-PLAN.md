---
phase: 07-automated-testing-suite
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/unit/auth/authenticator.test.ts
  - tests/unit/backup/manager.test.ts
  - tests/unit/config/manager.test.ts
  - tests/unit/common/degradation.test.ts
  - tests/mocks/browser-mocks.ts
autonomous: true

must_haves:
  truths:
    - "Auth module validates session tokens and detects logout"
    - "Backup module serializes/restores state and handles corruption"
    - "Config module validates schemas and applies defaults"
    - "Degradation module handles offline mode and fallback chains"
  artifacts:
    - path: "tests/unit/auth/authenticator.test.ts"
      provides: "Auth module unit tests"
      min_lines: 50
    - path: "tests/unit/backup/manager.test.ts"
      provides: "Backup module unit tests"
      min_lines: 50
    - path: "tests/unit/config/manager.test.ts"
      provides: "Config module unit tests"
      min_lines: 40
    - path: "tests/unit/common/degradation.test.ts"
      provides: "Degradation module unit tests"
      min_lines: 40
    - path: "tests/mocks/browser-mocks.ts"
      provides: "Shared Playwright mocks"
      exports: ["createMockPage", "createMockContext"]
  key_links:
    - from: "tests/unit/auth/authenticator.test.ts"
      to: "src/auth/authenticator.ts"
      via: "import and test"
      pattern: "import.*Authenticator"
    - from: "tests/unit/backup/manager.test.ts"
      to: "src/backup/manager.ts"
      via: "import and test"
      pattern: "import.*BackupManager"
---

<objective>
Create comprehensive unit tests for critical modules (auth, backup, config, degradation) with mocked dependencies to achieve 80%+ coverage.

**Purpose:** Validate core reliability features work correctly in isolation before integration testing. Mocked dependencies ensure tests are fast (< 5s total) and deterministic.

**Output:** 4 test suites covering auth, backup, config, and degradation modules with shared browser mocks for Playwright dependencies.
</objective>

<execution_context>
@C:\Users\lucid\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\lucid\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-automated-testing-suite/07-RESEARCH.md
@.planning/phases/07-automated-testing-suite/07-01-SUMMARY.md

# Modules to test
@src/auth/authenticator.ts
@src/backup/manager.ts
@src/config/manager.ts
@src/common/degradation.ts

# Test infrastructure
@tests/setup.ts
@vitest.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create browser mocks and auth tests</name>
  <files>tests/mocks/browser-mocks.ts, tests/unit/auth/authenticator.test.ts</files>
  <action>
Create `tests/mocks/browser-mocks.ts` for shared Playwright mocks:

```typescript
import { vi } from "vitest";
import type { Page, BrowserContext, Cookie } from "playwright";

export function createMockPage(options?: {
  cookies?: Cookie[];
  url?: string;
}): Page {
  const mockPage = {
    cookies: vi.fn().mockResolvedValue(options?.cookies ?? []),
    url: vi.fn().mockReturnValue(options?.url ?? "https://notebooklm.google.com"),
    goto: vi.fn().mockResolvedValue(null),
    waitForLoadState: vi.fn().mockResolvedValue(null),
    context: vi.fn().mockReturnValue(createMockContext({ cookies: options?.cookies })),
  } as unknown as Page;

  return mockPage;
}

export function createMockContext(options?: {
  cookies?: Cookie[];
}): BrowserContext {
  const mockContext = {
    cookies: vi.fn().mockResolvedValue(options?.cookies ?? []),
    addCookies: vi.fn().mockResolvedValue(null),
  } as unknown as BrowserContext;

  return mockContext;
}
```

Create `tests/unit/auth/authenticator.test.ts`:

```typescript
import { describe, it, expect, vi } from "vitest";
import { Authenticator } from "../../../src/auth/authenticator.js";
import { createMockPage } from "../../mocks/browser-mocks.js";
import type { Cookie } from "playwright";

describe("Authenticator", () => {
  describe("validateSession", () => {
    it("returns authenticated=true with valid SID cookie", async () => {
      const cookies: Cookie[] = [
        {
          name: "SID",
          value: "valid-session-token",
          domain: ".google.com",
          path: "/",
          expires: -1,
          httpOnly: false,
          secure: true,
          sameSite: "Lax",
        },
      ];
      const mockPage = createMockPage({ cookies });
      const auth = new Authenticator(mockPage);

      const result = await auth.validateSession();

      expect(result.authenticated).toBe(true);
      expect(result.sessionId).toBe("valid-session-token");
    });

    it("returns authenticated=false when SID cookie missing", async () => {
      const mockPage = createMockPage({ cookies: [] });
      const auth = new Authenticator(mockPage);

      const result = await auth.validateSession();

      expect(result.authenticated).toBe(false);
      expect(result.reason).toContain("session cookie");
    });

    it("returns authenticated=false with expired SID cookie", async () => {
      const cookies: Cookie[] = [
        {
          name: "SID",
          value: "expired-token",
          domain: ".google.com",
          path: "/",
          expires: Date.now() - 86400_000, // 1 day ago
          httpOnly: false,
          secure: true,
          sameSite: "Lax",
        },
      ];
      const mockPage = createMockPage({ cookies });
      const auth = new Authenticator(mockPage);

      const result = await auth.validateSession();

      expect(result.authenticated).toBe(false);
      expect(result.reason).toContain("expired");
    });
  });

  describe("detectLogout", () => {
    it("detects logout when previously valid session becomes invalid", async () => {
      const validCookies: Cookie[] = [
        {
          name: "SID",
          value: "session-123",
          domain: ".google.com",
          path: "/",
          expires: -1,
          httpOnly: false,
          secure: true,
          sameSite: "Lax",
        },
      ];
      const mockPage = createMockPage({ cookies: validCookies });
      const auth = new Authenticator(mockPage);

      const firstCheck = await auth.validateSession();
      expect(firstCheck.authenticated).toBe(true);

      // Simulate logout - cookies cleared
      mockPage.cookies = vi.fn().mockResolvedValue([]);

      const secondCheck = await auth.validateSession();
      expect(secondCheck.authenticated).toBe(false);
      expect(secondCheck.reason).toContain("logout");
    });
  });
});
```

**Test coverage:**
- Valid session token → authenticated
- Missing session cookie → not authenticated
- Expired token → not authenticated
- Logout detection → state change from valid to invalid
  </action>
  <verify>
```bash
npm run test -- tests/unit/auth/authenticator.test.ts
```
All auth tests pass.
  </verify>
  <done>Auth module has unit tests covering token validation, expiry, and logout detection with mocked Playwright Page</done>
</task>

<task type="auto">
  <name>Task 2: Create backup and config tests</name>
  <files>tests/unit/backup/manager.test.ts, tests/unit/config/manager.test.ts</files>
  <action>
Create `tests/unit/backup/manager.test.ts`:

```typescript
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { BackupManager } from "../../../src/backup/manager.js";
import { createTestDir, cleanupTestDir } from "../../setup.js";
import fs from "node:fs";
import path from "node:path";

describe("BackupManager", () => {
  let testDir: string;
  let backupManager: BackupManager;

  beforeEach(() => {
    testDir = createTestDir("backup-test");
    backupManager = new BackupManager(testDir);
  });

  afterEach(() => {
    cleanupTestDir(testDir);
  });

  describe("saveState", () => {
    it("serializes state to JSON file", async () => {
      const state = { sessionId: "test-123", timestamp: Date.now() };

      await backupManager.saveState(state);

      const backupPath = path.join(testDir, "backup.json");
      expect(fs.existsSync(backupPath)).toBe(true);

      const saved = JSON.parse(fs.readFileSync(backupPath, "utf-8"));
      expect(saved.sessionId).toBe("test-123");
    });

    it("creates backup directory if missing", async () => {
      const missingDir = path.join(testDir, "subdir", "backup");
      const manager = new BackupManager(missingDir);

      await manager.saveState({ data: "test" });

      expect(fs.existsSync(missingDir)).toBe(true);
    });
  });

  describe("restoreState", () => {
    it("restores state from valid backup", async () => {
      const originalState = { sessionId: "restore-test", data: "value" };
      await backupManager.saveState(originalState);

      const restored = await backupManager.restoreState();

      expect(restored.success).toBe(true);
      expect(restored.state.sessionId).toBe("restore-test");
    });

    it("detects corrupted backup (invalid JSON)", async () => {
      const backupPath = path.join(testDir, "backup.json");
      fs.writeFileSync(backupPath, "not-valid-json{");

      const result = await backupManager.restoreState();

      expect(result.success).toBe(false);
      expect(result.error).toContain("corrupt");
    });

    it("handles missing backup file gracefully", async () => {
      const result = await backupManager.restoreState();

      expect(result.success).toBe(false);
      expect(result.error).toContain("not found");
    });
  });

  describe("rollback", () => {
    it("restores previous backup on corruption", async () => {
      await backupManager.saveState({ version: 1 });
      await backupManager.saveState({ version: 2 });

      // Corrupt latest backup
      const latestPath = path.join(testDir, "backup.json");
      fs.writeFileSync(latestPath, "corrupted");

      const result = await backupManager.rollback();

      expect(result.success).toBe(true);
      expect(result.state.version).toBe(1); // Previous backup
    });
  });
});
```

Create `tests/unit/config/manager.test.ts`:

```typescript
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { ConfigManager } from "../../../src/config/manager.js";
import { createTestDir, cleanupTestDir } from "../../setup.js";
import fs from "node:fs";
import path from "node:path";

describe("ConfigManager", () => {
  let testDir: string;
  let configManager: ConfigManager;

  beforeEach(() => {
    testDir = createTestDir("config-test");
    configManager = new ConfigManager(testDir);
  });

  afterEach(() => {
    cleanupTestDir(testDir);
  });

  describe("load", () => {
    it("loads valid config from disk", async () => {
      const configPath = path.join(testDir, "config.json");
      const validConfig = {
        version: "0.1.0",
        notebookUrl: "https://notebooklm.google.com/notebook/abc123",
        relevanceThreshold: 30,
      };
      fs.writeFileSync(configPath, JSON.stringify(validConfig));

      const config = await configManager.load();

      expect(config.version).toBe("0.1.0");
      expect(config.notebookUrl).toBe(validConfig.notebookUrl);
    });

    it("applies defaults for missing optional fields", async () => {
      const configPath = path.join(testDir, "config.json");
      const minimalConfig = {
        version: "0.1.0",
        notebookUrl: "https://notebooklm.google.com/notebook/abc123",
      };
      fs.writeFileSync(configPath, JSON.stringify(minimalConfig));

      const config = await configManager.load();

      expect(config.relevanceThreshold).toBeDefined();
      expect(config.maxIterations).toBeDefined();
    });

    it("throws on invalid notebookUrl", async () => {
      const configPath = path.join(testDir, "config.json");
      const invalidConfig = {
        version: "0.1.0",
        notebookUrl: "not-a-url",
      };
      fs.writeFileSync(configPath, JSON.stringify(invalidConfig));

      await expect(configManager.load()).rejects.toThrow("invalid");
    });

    it("throws on missing required version field", async () => {
      const configPath = path.join(testDir, "config.json");
      const invalidConfig = {
        notebookUrl: "https://notebooklm.google.com/notebook/abc123",
      };
      fs.writeFileSync(configPath, JSON.stringify(invalidConfig));

      await expect(configManager.load()).rejects.toThrow("version");
    });
  });

  describe("validate", () => {
    it("accepts valid config object", () => {
      const validConfig = {
        version: "0.1.0",
        notebookUrl: "https://notebooklm.google.com/notebook/abc123",
        relevanceThreshold: 40,
      };

      const result = configManager.validate(validConfig);

      expect(result.valid).toBe(true);
    });

    it("rejects config with relevanceThreshold > 100", () => {
      const invalidConfig = {
        version: "0.1.0",
        notebookUrl: "https://notebooklm.google.com/notebook/abc123",
        relevanceThreshold: 150,
      };

      const result = configManager.validate(invalidConfig);

      expect(result.valid).toBe(false);
      expect(result.errors[0]).toContain("relevanceThreshold");
    });
  });
});
```

**Test coverage:**
- Backup: save, restore, corruption detection, rollback
- Config: load, defaults, validation, schema enforcement
  </action>
  <verify>
```bash
npm run test -- tests/unit/backup tests/unit/config
```
All backup and config tests pass.
  </verify>
  <done>Backup and config modules have unit tests covering serialization, restoration, corruption handling, validation, and defaults</done>
</task>

<task type="auto">
  <name>Task 3: Create degradation module tests</name>
  <files>tests/unit/common/degradation.test.ts</files>
  <action>
Create `tests/unit/common/degradation.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { DegradationHandler } from "../../../src/common/degradation.js";

describe("DegradationHandler", () => {
  let handler: DegradationHandler;

  beforeEach(() => {
    handler = new DegradationHandler();
  });

  describe("offline mode", () => {
    it("uses cached responses when offline", async () => {
      handler.setCache("test-key", { data: "cached-value" });
      handler.setOfflineMode(true);

      const result = await handler.get("test-key");

      expect(result).toEqual({ data: "cached-value" });
    });

    it("returns null for cache miss in offline mode", async () => {
      handler.setOfflineMode(true);

      const result = await handler.get("missing-key");

      expect(result).toBeNull();
    });
  });

  describe("fallback chain", () => {
    it("tries primary, then fallback on failure", async () => {
      const primary = vi.fn().mockRejectedValue(new Error("primary failed"));
      const fallback = vi.fn().mockResolvedValue("fallback-value");

      const result = await handler.withFallback(primary, fallback);

      expect(primary).toHaveBeenCalled();
      expect(fallback).toHaveBeenCalled();
      expect(result).toBe("fallback-value");
    });

    it("uses primary if it succeeds", async () => {
      const primary = vi.fn().mockResolvedValue("primary-value");
      const fallback = vi.fn().mockResolvedValue("fallback-value");

      const result = await handler.withFallback(primary, fallback);

      expect(primary).toHaveBeenCalled();
      expect(fallback).not.toHaveBeenCalled();
      expect(result).toBe("primary-value");
    });

    it("throws if both primary and fallback fail", async () => {
      const primary = vi.fn().mockRejectedValue(new Error("primary failed"));
      const fallback = vi.fn().mockRejectedValue(new Error("fallback failed"));

      await expect(handler.withFallback(primary, fallback)).rejects.toThrow(
        "fallback failed"
      );
    });
  });

  describe("recovery trigger", () => {
    it("changes degradation level on repeated failures", async () => {
      const operation = vi.fn().mockRejectedValue(new Error("fail"));

      handler.trackFailure("browser-launch");
      handler.trackFailure("browser-launch");
      handler.trackFailure("browser-launch");

      const level = handler.getDegradationLevel();

      expect(level).toBe("degraded"); // After 3 failures
    });

    it("resets degradation level after success", async () => {
      handler.trackFailure("test-op");
      handler.trackFailure("test-op");

      expect(handler.getDegradationLevel()).toBe("degraded");

      handler.trackSuccess("test-op");

      expect(handler.getDegradationLevel()).toBe("normal");
    });
  });

  describe("capability detection", () => {
    it("reports degraded services", () => {
      handler.trackFailure("notebooklm-connection");
      handler.trackFailure("notebooklm-connection");

      const status = handler.getStatus();

      expect(status.degradedServices).toContain("notebooklm-connection");
      expect(status.level).toBe("degraded");
    });

    it("provides user-facing status message", () => {
      handler.setOfflineMode(true);

      const status = handler.getStatus();

      expect(status.message).toContain("offline");
      expect(status.message).toContain("cache");
    });
  });
});
```

**Test coverage:**
- Offline mode with cache
- Fallback chain execution
- Recovery trigger on repeated failures
- Capability detection and status reporting
  </action>
  <verify>
```bash
npm run test -- tests/unit/common/degradation.test.ts
npm run test:coverage -- tests/unit/
```
All unit tests pass, coverage reports show 80%+ on auth, backup, config, degradation modules.
  </verify>
  <done>Degradation module has unit tests covering offline mode, fallback chains, recovery triggers, and capability detection</done>
</task>

</tasks>

<verification>
**Unit test checks:**
1. Run `npm run test -- tests/unit/` - all tests pass
2. Run `npm run test:coverage -- tests/unit/` - coverage reports show:
   - `src/auth/authenticator.ts`: 80%+ lines/functions
   - `src/backup/manager.ts`: 80%+ lines/functions
   - `src/config/manager.ts`: 80%+ lines/functions
   - `src/common/degradation.ts`: 80%+ lines/functions
3. Check that all tests use mocked dependencies (no real browser, no real filesystem in auth tests)
4. Verify tests run fast (< 5 seconds for all unit tests)

**Mock quality:**
- `tests/mocks/browser-mocks.ts` provides reusable Playwright mocks
- Mocks are simple and focused (only mock what's needed)
</verification>

<success_criteria>
**Unit tests are complete when:**
1. Auth module tests cover token validation, expiry, logout detection
2. Backup module tests cover save, restore, corruption, rollback
3. Config module tests cover load, validate, defaults, schema enforcement
4. Degradation module tests cover offline mode, fallback chains, recovery triggers
5. All unit tests use mocked dependencies (no real I/O)
6. Coverage reports show 80%+ on all critical modules
7. Unit test suite runs in < 5 seconds
</success_criteria>

<output>
After completion, create `.planning/phases/07-automated-testing-suite/07-02-SUMMARY.md` with:
- Test suites created (auth, backup, config, degradation)
- Coverage achieved per module (% lines/functions/branches)
- Shared mocks created (browser-mocks.ts)
- Test execution time (target: < 5s)
- Next steps: Mock NotebookLM UI for integration tests (07-03)
</output>
