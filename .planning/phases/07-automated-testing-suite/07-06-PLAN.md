---
phase: 07-automated-testing-suite
plan: 06
type: execute
wave: 3
depends_on: ["07-02", "07-04", "07-05"]
files_modified:
  - tests/unit/bidirectional/response-parser.test.ts
  - tests/unit/knowledge/report-compiler.test.ts
  - .github/workflows/test.yml
  - package.json
autonomous: true

must_haves:
  truths:
    - "Snapshot tests validate response parsing output stability"
    - "Coverage reports show 80%+ on critical paths"
    - "Test suite passes in CI with coverage enforcement"
  artifacts:
    - path: "tests/unit/bidirectional/response-parser.test.ts"
      provides: "Snapshot tests for response parsing"
      contains: "toMatchSnapshot"
      min_lines: 40
    - path: "tests/unit/knowledge/report-compiler.test.ts"
      provides: "Snapshot tests for markdown compilation"
      contains: "toMatchSnapshot"
      min_lines: 30
    - path: ".github/workflows/test.yml"
      provides: "CI workflow with coverage checks"
      contains: "vitest.*--coverage"
  key_links:
    - from: "tests/unit/bidirectional/response-parser.test.ts"
      to: "src/bidirectional/response-parser.ts"
      via: "import and snapshot test"
      pattern: "toMatchSnapshot"
    - from: ".github/workflows/test.yml"
      to: "npm run test:coverage"
      via: "CI script execution"
      pattern: "npm.*test:coverage"
---

<objective>
Add snapshot testing for response parsing and markdown compilation, validate coverage thresholds, and prepare CI integration for automated testing.

**Purpose:** Ensure response parsing and report generation outputs remain stable across changes (snapshot testing) and verify that test coverage meets 80%+ target on critical paths before merging.

**Output:** Snapshot tests for response parsing and report compilation, coverage validation script, and CI workflow configuration for automated testing.
</objective>

<execution_context>
@C:\Users\lucid\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\lucid\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-automated-testing-suite/07-RESEARCH.md
@.planning/phases/07-automated-testing-suite/07-01-SUMMARY.md
@.planning/phases/07-automated-testing-suite/07-02-SUMMARY.md
@.planning/phases/07-automated-testing-suite/07-04-SUMMARY.md
@.planning/phases/07-automated-testing-suite/07-05-SUMMARY.md

# Modules to snapshot test
@src/bidirectional/response-parser.ts
@src/knowledge/report-compiler.ts

# Test infrastructure
@vitest.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create snapshot tests for response parsing</name>
  <files>tests/unit/bidirectional/response-parser.test.ts</files>
  <action>
Create `tests/unit/bidirectional/response-parser.test.ts`:

```typescript
import { describe, it, expect } from "vitest";
import { ResponseParser } from "../../../src/bidirectional/response-parser.js";

describe("ResponseParser snapshots", () => {
  const parser = new ResponseParser();

  it("parses simple response with citations", () => {
    const html = `
      <div data-message-author="assistant">
        <p>Authentication uses OAuth 2.0 tokens for secure access.</p>
        <cite>[Source: auth.md]</cite>
      </div>
    `;

    const result = parser.parse(html);

    expect(result).toMatchSnapshot();
    // Also validate key fields
    expect(result.answer).toBe("Authentication uses OAuth 2.0 tokens for secure access.");
    expect(result.citations).toEqual(["Source: auth.md"]);
  });

  it("parses complex response with multiple paragraphs and citations", () => {
    const html = `
      <div data-message-author="assistant">
        <p>MSW Protocol bridges NotebookLM and coding agents.</p>
        <p>The system uses browser automation with Playwright for stealth.</p>
        <p>Auto-conversation explores topics up to 5 levels deep.</p>
        <cite>[Source: overview.md]</cite>
        <cite>[Source: browser.md]</cite>
        <cite>[Source: auto-conversation.md]</cite>
      </div>
    `;

    const result = parser.parse(html);

    expect(result).toMatchSnapshot();
    expect(result.answer).toContain("MSW Protocol");
    expect(result.citations).toHaveLength(3);
  });

  it("handles response with code blocks", () => {
    const html = `
      <div data-message-author="assistant">
        <p>Example TypeScript interface:</p>
        <pre><code>interface Config {
  version: string;
  notebookUrl: string;
}</code></pre>
        <p>This defines the configuration structure.</p>
        <cite>[Source: config.md]</cite>
      </div>
    `;

    const result = parser.parse(html);

    expect(result).toMatchSnapshot();
    expect(result.answer).toContain("interface Config");
  });

  it("handles response with lists", () => {
    const html = `
      <div data-message-author="assistant">
        <p>Key features:</p>
        <ul>
          <li>Browser automation with Playwright</li>
          <li>Auto-conversation engine</li>
          <li>Bidirectional communication</li>
        </ul>
        <cite>[Source: features.md]</cite>
      </div>
    `;

    const result = parser.parse(html);

    expect(result).toMatchSnapshot();
    expect(result.answer).toContain("Browser automation");
    expect(result.answer).toContain("Auto-conversation");
  });

  it("handles response with no citations", () => {
    const html = `
      <div data-message-author="assistant">
        <p>This is a general response without specific sources.</p>
      </div>
    `;

    const result = parser.parse(html);

    expect(result).toMatchSnapshot();
    expect(result.citations).toHaveLength(0);
  });

  it("handles malformed HTML gracefully", () => {
    const html = `
      <div data-message-author="assistant">
        <p>Unclosed paragraph
        <cite>Unclosed citation
      </div>
    `;

    const result = parser.parse(html);

    expect(result).toMatchSnapshot();
    // Should still extract some content
    expect(result.answer).toBeTruthy();
  });
});
```

**Snapshot coverage:**
- Simple response with citation
- Complex multi-paragraph response
- Code blocks in response
- Lists in response
- No citations edge case
- Malformed HTML handling
  </action>
  <verify>
```bash
npm run test -- tests/unit/bidirectional/response-parser.test.ts
```
Snapshot tests pass, snapshots created in `__snapshots__/` directory.
  </verify>
  <done>Response parser has snapshot tests validating output stability across various HTML structures</done>
</task>

<task type="auto">
  <name>Task 2: Create snapshot tests for report compilation</name>
  <files>tests/unit/knowledge/report-compiler.test.ts</files>
  <action>
Create `tests/unit/knowledge/report-compiler.test.ts`:

```typescript
import { describe, it, expect } from "vitest";
import { ReportCompiler } from "../../../src/knowledge/report-compiler.js";

describe("ReportCompiler snapshots", () => {
  const compiler = new ReportCompiler();

  it("compiles single Q&A pair to markdown", () => {
    const qaPairs = [
      {
        question: "How does authentication work?",
        answer: "MSW uses persistent Chrome profiles to maintain Google session cookies.",
        citations: ["auth.md", "browser.md"],
        timestamp: new Date("2026-02-03T10:00:00Z"),
      },
    ];

    const markdown = compiler.compile(qaPairs);

    expect(markdown).toMatchSnapshot();
    // Validate structure
    expect(markdown).toContain("# Research Report");
    expect(markdown).toContain("## Q:");
    expect(markdown).toContain("**Sources:**");
  });

  it("compiles multiple Q&A pairs with metadata", () => {
    const qaPairs = [
      {
        question: "How does authentication work?",
        answer: "Uses persistent Chrome profiles.",
        citations: ["auth.md"],
        timestamp: new Date("2026-02-03T10:00:00Z"),
      },
      {
        question: "How does error handling work?",
        answer: "Errors trigger NotebookLM queries for guidance.",
        citations: ["error-handling.md"],
        timestamp: new Date("2026-02-03T10:05:00Z"),
      },
      {
        question: "How does testing work?",
        answer: "Three-tier testing: unit, integration, E2E.",
        citations: ["testing.md"],
        timestamp: new Date("2026-02-03T10:10:00Z"),
      },
    ];

    const markdown = compiler.compile(qaPairs, {
      title: "MSW Research Session",
      sessionId: "test-session-123",
      generatedAt: new Date("2026-02-03T10:15:00Z"),
    });

    expect(markdown).toMatchSnapshot();
    expect(markdown).toContain("MSW Research Session");
    expect(markdown).toContain("Session ID: test-session-123");
  });

  it("compiles report with suggested topics", () => {
    const qaPairs = [
      {
        question: "Initial question",
        answer: "Initial answer",
        citations: ["doc.md"],
        suggestedTopics: [
          "Learn about advanced features",
          "Learn about troubleshooting",
        ],
        timestamp: new Date("2026-02-03T10:00:00Z"),
      },
    ];

    const markdown = compiler.compile(qaPairs);

    expect(markdown).toMatchSnapshot();
    expect(markdown).toContain("**Suggested Topics:**");
    expect(markdown).toContain("- Learn about advanced features");
  });

  it("handles Q&A pairs with no citations", () => {
    const qaPairs = [
      {
        question: "General question",
        answer: "General answer without specific sources",
        citations: [],
        timestamp: new Date("2026-02-03T10:00:00Z"),
      },
    ];

    const markdown = compiler.compile(qaPairs);

    expect(markdown).toMatchSnapshot();
    expect(markdown).not.toContain("**Sources:**");
  });

  it("formats timestamps in human-readable format", () => {
    const qaPairs = [
      {
        question: "Test question",
        answer: "Test answer",
        citations: ["test.md"],
        timestamp: new Date("2026-02-03T14:30:45Z"),
      },
    ];

    const markdown = compiler.compile(qaPairs);

    expect(markdown).toMatchSnapshot();
    // Should include formatted timestamp
    expect(markdown).toMatch(/\d{4}-\d{2}-\d{2}/); // YYYY-MM-DD format
  });

  it("escapes markdown special characters in answers", () => {
    const qaPairs = [
      {
        question: "How to use # and * in code?",
        answer: "Use `#hashtag` and `*asterisk*` in markdown code blocks.",
        citations: ["markdown.md"],
        timestamp: new Date("2026-02-03T10:00:00Z"),
      },
    ];

    const markdown = compiler.compile(qaPairs);

    expect(markdown).toMatchSnapshot();
    // Should preserve code formatting
    expect(markdown).toContain("`#hashtag`");
    expect(markdown).toContain("`*asterisk*`");
  });
});
```

**Snapshot coverage:**
- Single Q&A pair
- Multiple Q&A pairs with metadata
- Suggested topics included
- No citations edge case
- Timestamp formatting
- Markdown escaping
  </action>
  <verify>
```bash
npm run test -- tests/unit/knowledge/report-compiler.test.ts
```
Snapshot tests pass, snapshots created.
  </verify>
  <done>Report compiler has snapshot tests validating markdown output stability across various Q&A structures</done>
</task>

<task type="auto">
  <name>Task 3: Add coverage validation and CI workflow</name>
  <files>package.json, .github/workflows/test.yml</files>
  <action>
Add coverage validation script to `package.json`:

```json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "test:ui": "vitest --ui",
    "test:validate-coverage": "vitest run --coverage && node scripts/validate-coverage.js"
  }
}
```

Create `.github/workflows/test.yml`:

```yaml
name: Test Suite

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x, 20.x, 22.x]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        run: npm run test:coverage

      - name: Check coverage thresholds
        run: |
          if [ -f coverage/coverage-summary.json ]; then
            echo "Coverage report generated"
            cat coverage/coverage-summary.json | jq '.total'
          else
            echo "No coverage report found"
            exit 1
          fi

      - name: Upload coverage to Codecov
        if: matrix.node-version == '20.x'
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage/lcov.info
          flags: unittests
          fail_ci_if_error: false

      - name: Comment coverage on PR
        if: github.event_name == 'pull_request' && matrix.node-version == '20.x'
        uses: romeovs/lcov-reporter-action@v0.3.1
        with:
          lcov-file: ./coverage/lcov.info
          github-token: ${{ secrets.GITHUB_TOKEN }}
```

Create `scripts/validate-coverage.js`:

```javascript
#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const coveragePath = path.join(__dirname, "../coverage/coverage-summary.json");

if (!fs.existsSync(coveragePath)) {
  console.error("âŒ Coverage report not found");
  process.exit(1);
}

const coverage = JSON.parse(fs.readFileSync(coveragePath, "utf-8"));

// Critical paths requiring 80%+ coverage
const criticalPaths = [
  "src/auth/",
  "src/backup/",
  "src/config/",
  "src/common/degradation.ts",
  "src/browser/driver.ts",
  "src/mcp/tools/",
];

let passed = true;

console.log("\nðŸ“Š Coverage Validation\n");

for (const [file, metrics] of Object.entries(coverage)) {
  if (file === "total") continue;

  const isCritical = criticalPaths.some((p) => file.includes(p));

  if (isCritical) {
    const lines = metrics.lines.pct;
    const functions = metrics.functions.pct;
    const threshold = file.includes("browser/driver.ts") ? 85 : 80;

    if (lines < threshold || functions < threshold) {
      console.error(
        `âŒ ${file}: Lines ${lines}%, Functions ${functions}% (expected ${threshold}%+)`
      );
      passed = false;
    } else {
      console.log(
        `âœ… ${file}: Lines ${lines}%, Functions ${functions}%`
      );
    }
  }
}

const total = coverage.total;
console.log(`\nðŸ“ˆ Total Coverage: Lines ${total.lines.pct}%, Functions ${total.functions.pct}%, Branches ${total.branches.pct}%\n`);

if (!passed) {
  console.error("âŒ Coverage validation failed\n");
  process.exit(1);
}

console.log("âœ… Coverage validation passed\n");
```

Make script executable:

```bash
chmod +x scripts/validate-coverage.js
```

**CI features:**
- Multi-Node version matrix (18, 20, 22)
- Coverage generation and threshold checks
- Codecov upload for historical tracking
- PR comments with coverage diff
  </action>
  <verify>
```bash
# Validate coverage locally
npm run test:coverage
node scripts/validate-coverage.js

# Check CI workflow syntax
cat .github/workflows/test.yml | grep -E "(name|run):"
```
Coverage validation script runs successfully, CI workflow is well-formed.
  </verify>
  <done>Coverage validation script enforces 80%+ thresholds on critical paths and CI workflow runs tests with coverage checks</done>
</task>

</tasks>

<verification>
**Snapshot test checks:**
1. Run `npm run test -- tests/unit/bidirectional tests/unit/knowledge` - snapshot tests pass
2. Check `tests/**/__snapshots__/` directory - snapshot files created
3. Modify a parser, run tests again - should detect snapshot mismatch

**Coverage validation checks:**
1. Run `npm run test:coverage` - coverage reports generated
2. Run `node scripts/validate-coverage.js` - validation passes
3. Check coverage HTML report - critical paths show 80%+ coverage

**CI workflow checks:**
1. Validate workflow syntax: `cat .github/workflows/test.yml`
2. CI should run on push and PR
3. Multi-Node matrix (18, 20, 22) defined
</verification>

<success_criteria>
**Phase 7 is complete when:**
1. Snapshot tests validate response parser output stability
2. Snapshot tests validate report compiler markdown output
3. Coverage validation script enforces 80%+ thresholds on critical paths (auth, backup, config, degradation, browser driver, MCP tools)
4. CI workflow runs tests with coverage on multiple Node versions
5. All test suites (unit, integration, E2E, snapshot) pass consistently
6. Full test suite runs in < 3 minutes
7. Coverage reports show 80%+ on critical paths, 70%+ overall
</success_criteria>

<output>
After completion, create `.planning/phases/07-automated-testing-suite/07-06-SUMMARY.md` with:
- Snapshot tests created (response-parser, report-compiler)
- Coverage validation script implemented (threshold enforcement)
- CI workflow configured (multi-Node, coverage upload, PR comments)
- Final coverage statistics (per module, total)
- Test suite performance metrics (unit < 5s, integration < 30s, E2E < 2min, total < 3min)
- Phase 7 complete: Automated Testing Suite deployed with 80%+ coverage on critical paths
</output>
