---
phase: 05-gsd-ralph-integration
plan: 07
type: execute
wave: 3
depends_on: ["05-04", "05-06"]
files_modified:
  - src/execution/ralph-runner.ts
  - src/execution/behavioral-verifier.ts
autonomous: true

must_haves:
  truths:
    - "Ralph runner initializes state, configures stop hook, and provides start/status/stop API"
    - "Behavioral verifier runs actual tests/commands rather than just checking file existence"
    - "Stop hook configuration is generated for .claude/settings.json"
  artifacts:
    - path: "src/execution/ralph-runner.ts"
      provides: "Orchestrator that sets up and manages Ralph loop lifecycle"
      exports: ["RalphRunner"]
    - path: "src/execution/behavioral-verifier.ts"
      provides: "Runs test commands and validates actual functionality"
      exports: ["BehavioralVerifier"]
  key_links:
    - from: "src/execution/ralph-runner.ts"
      to: "src/execution/iteration-tracker.ts"
      via: "creates and manages IterationTracker"
      pattern: "new IterationTracker"
    - from: "src/execution/ralph-runner.ts"
      to: ".claude/settings.json"
      via: "generates hook configuration"
      pattern: "settings\\.json"
---

<objective>
Create the Ralph runner (orchestrates loop lifecycle) and behavioral verifier (validates actual functionality).

Purpose: RalphRunner is the main entry point that MCP tools call. BehavioralVerifier ensures we check real behavior, not just structure.
Output: RalphRunner class + BehavioralVerifier class.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-gsd-ralph-integration/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Behavioral verifier</name>
  <files>src/execution/behavioral-verifier.ts</files>
  <action>
  Create `src/execution/behavioral-verifier.ts` class `BehavioralVerifier`:

  Interface `VerificationSpec`: commands (string[]), expectedOutputPatterns? (Record<string, string> -- command -> regex pattern), timeoutMs? (default 30000)

  `verify(spec: VerificationSpec): { passed: boolean, results: Array<{ command: string, exitCode: number, stdout: string, passed: boolean, reason?: string }> }`:
  1. Run each command via child_process.execSync with timeout
  2. Check exit code === 0
  3. If expectedOutputPatterns provided for this command, check stdout matches regex
  4. Collect all results. passed = all individual results passed.

  Handle timeouts (mark as failed with reason "timeout"). Handle command not found (mark as failed). Never throw -- always return structured result.
  </action>
  <verify>`npx tsc --noEmit src/execution/behavioral-verifier.ts`</verify>
  <done>BehavioralVerifier runs real commands and reports structured pass/fail results.</done>
</task>

<task type="auto">
  <name>Task 2: Ralph runner orchestrator</name>
  <files>src/execution/ralph-runner.ts</files>
  <action>
  Create `src/execution/ralph-runner.ts` class `RalphRunner`:

  Constructor takes: `projectDir: string`

  `start(config: RalphConfig): { hookConfig: object }`:
  1. Create IterationTracker, call init(config)
  2. Generate hook config object for .claude/settings.json:
     ```json
     { "hooks": { "Stop": [{ "hooks": [{ "type": "command", "command": "node \"$CLAUDE_PROJECT_DIR/dist/execution/stop-hook.js\"", "timeout": 60 }] }] } }
     ```
  3. Return the hookConfig so caller (MCP tool) can write it

  `status(): RalphState | null` -- loads and returns current state via tracker

  `stop(): void` -- calls tracker.reset()

  `getHookConfigPath(): string` -- returns path to .claude/settings.json (or settings.local.json)

  `installHook(): void` -- reads existing settings.json, merges Stop hook config, writes back. If file doesn't exist, creates it. Preserves existing hooks.

  Use path.join for all paths. Handle both Stop and SubagentStop events (register same hook for both, per research open question #3).
  </action>
  <verify>`npx tsc --noEmit src/execution/ralph-runner.ts`</verify>
  <done>RalphRunner initializes loop state, generates and installs hook config, provides status/stop API.</done>
</task>

</tasks>

<verification>
Both files compile. RalphRunner generates valid hook configuration JSON.
</verification>

<success_criteria>
Ralph loop can be started/stopped programmatically. Hook config installs into .claude/settings.json. Behavioral verification runs real commands.
</success_criteria>

<output>
After completion, create `.planning/phases/05-gsd-ralph-integration/05-07-SUMMARY.md`
</output>
