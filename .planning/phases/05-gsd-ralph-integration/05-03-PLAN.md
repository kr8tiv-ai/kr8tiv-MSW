---
phase: 05-gsd-ralph-integration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/execution.ts
  - src/execution/iteration-tracker.ts
autonomous: true

must_haves:
  truths:
    - "Ralph state persists to .msw/ralph-state.json and survives process restarts"
    - "Max iterations are enforced -- tracker returns 'exceeded' when limit reached"
    - "Stale state (lastHeartbeat > 1 hour) is detected and can be reset"
  artifacts:
    - path: "src/types/execution.ts"
      provides: "RalphState, RalphConfig, IterationResult interfaces"
      exports: ["RalphState", "RalphConfig", "IterationResult"]
    - path: "src/execution/iteration-tracker.ts"
      provides: "File-based iteration tracking with heartbeat"
      exports: ["IterationTracker"]
  key_links:
    - from: "src/execution/iteration-tracker.ts"
      to: ".msw/ralph-state.json"
      via: "fs readFileSync/writeFileSync"
      pattern: "ralph-state\\.json"
---

<objective>
Create Ralph loop types and iteration tracker that persists state to `.msw/ralph-state.json`.

Purpose: Core state management for the Ralph loop. Stop hook and feedback injector depend on this.
Output: Types + IterationTracker class with init/increment/check/reset/heartbeat methods.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-gsd-ralph-integration/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Execution types and iteration tracker</name>
  <files>src/types/execution.ts, src/execution/iteration-tracker.ts</files>
  <action>
  Create `src/types/execution.ts`:
  - `RalphState`: active, prompt, completionPromise, iteration, maxIterations, startedAt, lastHeartbeat, lastError (string|null), notebookLmGuidance (string|null), queriedErrors (string[]), taskContext ({ phase, planId, description })
  - `RalphConfig`: prompt, completionPromise, maxIterations (default 50), notebookUrl?
  - `IterationResult`: 'continue' | 'complete' | 'exceeded'

  Create `src/execution/iteration-tracker.ts` class `IterationTracker`:
  - Constructor takes `projectDir: string`
  - `statePath` getter: `path.join(projectDir, '.msw', 'ralph-state.json')`
  - `init(config: RalphConfig): void` -- creates .msw dir, writes initial state with active=true, iteration=0
  - `load(): RalphState | null` -- reads state file, returns null if not found
  - `increment(): IterationResult` -- bumps iteration, updates heartbeat, checks maxIterations, writes state, returns result
  - `recordError(error: string): void` -- sets lastError in state
  - `recordGuidance(guidance: string): void` -- sets notebookLmGuidance in state
  - `addQueriedError(error: string): void` -- appends to queriedErrors array
  - `isStale(): boolean` -- lastHeartbeat > 1 hour ago
  - `reset(): void` -- sets active=false, writes state
  - `heartbeat(): void` -- updates lastHeartbeat timestamp

  Use zod for RalphState validation on load (already in project). Use sync fs operations.
  </action>
  <verify>`npx tsc --noEmit src/types/execution.ts src/execution/iteration-tracker.ts` compiles.</verify>
  <done>IterationTracker creates, reads, updates, and resets ralph-state.json. Stale detection works. Max iterations enforced.</done>
</task>

</tasks>

<verification>
TypeScript compiles. State file round-trips correctly.
</verification>

<success_criteria>
Ralph loop state persists across restarts, enforces limits, detects stale sessions.
</success_criteria>

<output>
After completion, create `.planning/phases/05-gsd-ralph-integration/05-03-SUMMARY.md`
</output>
