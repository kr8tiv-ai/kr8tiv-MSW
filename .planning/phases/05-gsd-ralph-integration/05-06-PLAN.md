---
phase: 05-gsd-ralph-integration
plan: 06
type: execute
wave: 2
depends_on: ["05-03"]
files_modified:
  - src/execution/feedback-injector.ts
  - src/execution/completion-detector.ts
autonomous: true

must_haves:
  truths:
    - "Failures trigger NotebookLM queries and store guidance in Ralph state"
    - "Duplicate errors are not re-queried (uses queriedErrors list + Phase 3 dedup)"
    - "Completion detector checks transcript for completion promise and optional test commands"
  artifacts:
    - path: "src/execution/feedback-injector.ts"
      provides: "Query NotebookLM on failure, cache guidance"
      exports: ["FeedbackInjector"]
    - path: "src/execution/completion-detector.ts"
      provides: "Detect task completion from transcript content"
      exports: ["CompletionDetector"]
  key_links:
    - from: "src/execution/feedback-injector.ts"
      to: "src/bidirectional/error-bridge.ts"
      via: "import ErrorBridge"
      pattern: "ErrorBridge"
    - from: "src/execution/feedback-injector.ts"
      to: "src/execution/iteration-tracker.ts"
      via: "records guidance and queried errors"
      pattern: "tracker\\.recordGuidance"
---

<objective>
Create the feedback injector (queries NotebookLM on failures) and completion detector (checks if task is done).

Purpose: These are the intelligence layer of the Ralph loop -- knowing when to get help and when to stop.
Output: FeedbackInjector class + CompletionDetector class.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-gsd-ralph-integration/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Feedback injector</name>
  <files>src/execution/feedback-injector.ts</files>
  <action>
  Create `src/execution/feedback-injector.ts` class `FeedbackInjector`:

  Constructor takes: `tracker: IterationTracker`, `errorBridge: ErrorBridge` (from Phase 3), `queryInjector: QueryInjector` (from Phase 3)

  `async getGuidance(error: string, taskContext: string): Promise<string | null>`:
  1. Load state from tracker. Check if error (or similar) already in queriedErrors -- if so, return cached notebookLmGuidance
  2. Format error via errorBridge.formatError(error, taskContext)
  3. Inject query via queryInjector and await response
  4. Store guidance in tracker via recordGuidance()
  5. Add error to queriedErrors via addQueriedError()
  6. Return the guidance string

  For error similarity: simple check -- if queriedErrors contains any string that shares >80% of words with current error, consider it duplicate. This avoids re-querying "TypeError: Cannot read properties of undefined (reading 'foo')" vs same with 'bar'.

  Handle NotebookLM query failures gracefully -- return null, log warning.
  </action>
  <verify>`npx tsc --noEmit src/execution/feedback-injector.ts`</verify>
  <done>FeedbackInjector queries NotebookLM for new errors, deduplicates, caches guidance.</done>
</task>

<task type="auto">
  <name>Task 2: Completion detector</name>
  <files>src/execution/completion-detector.ts</files>
  <action>
  Create `src/execution/completion-detector.ts` class `CompletionDetector`:

  Constructor takes: `completionPromise: string` (the string to look for in transcript)

  `checkTranscript(transcriptPath: string): boolean` -- reads transcript file, checks if completionPromise string appears. Returns true if found.

  `checkWithVerification(transcriptPath: string, verifyCommands: string[]): { complete: boolean, verifyResults: Array<{ command: string, passed: boolean }> }` -- checks transcript AND runs each verify command via child_process.execSync. A task is complete only if BOTH the promise is found AND all verify commands exit 0.

  Handle file-not-found on transcript gracefully (return false). Handle verify command failures gracefully (mark as not passed, don't throw).
  </action>
  <verify>`npx tsc --noEmit src/execution/completion-detector.ts`</verify>
  <done>CompletionDetector checks transcript for promise string and optionally runs verification commands.</done>
</task>

</tasks>

<verification>
Both files compile. FeedbackInjector deduplicates errors. CompletionDetector handles missing files.
</verification>

<success_criteria>
Failure feedback queries NotebookLM with dedup. Completion detection validates both promise and optional commands.
</success_criteria>

<output>
After completion, create `.planning/phases/05-gsd-ralph-integration/05-06-SUMMARY.md`
</output>
