---
phase: 05-gsd-ralph-integration
plan: 04
type: execute
wave: 2
depends_on: ["05-03"]
files_modified:
  - src/execution/stop-hook.ts
autonomous: true

must_haves:
  truths:
    - "Stop hook reads JSON from stdin and returns block/allow decision to stdout"
    - "Hook allows stop when: no active loop, max iterations reached, or completion promise found in transcript"
    - "Hook blocks stop and injects continuation prompt with NotebookLM guidance when available"
  artifacts:
    - path: "src/execution/stop-hook.ts"
      provides: "Standalone Node.js stop hook script for Claude Code"
      exports: []
  key_links:
    - from: "src/execution/stop-hook.ts"
      to: ".msw/ralph-state.json"
      via: "IterationTracker.load()"
      pattern: "tracker\\.load\\(\\)"
    - from: "src/execution/stop-hook.ts"
      to: "Claude Code hooks API"
      via: "stdin JSON / stdout JSON / exit code"
      pattern: "process\\.exit\\(0\\)"
---

<objective>
Implement the Ralph Stop hook as a standalone Node.js script that intercepts Claude Code exit and decides whether to continue looping.

Purpose: Core mechanism that keeps Claude iterating until task completion or max iterations.
Output: stop-hook.ts that compiles to a standalone script for use in .claude/settings.json.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-gsd-ralph-integration/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Stop hook script</name>
  <files>src/execution/stop-hook.ts</files>
  <action>
  Create `src/execution/stop-hook.ts` as a standalone entry point (not a module export):

  1. Read all stdin (JSON) using process.stdin data/end events
  2. Parse as StopHookInput: { session_id, transcript_path, cwd, hook_event_name, stop_hook_active }
  3. Create IterationTracker with cwd
  4. Load ralph state -- if null or not active, `process.exit(0)` (allow stop)
  5. If `stop_hook_active === true` AND iteration >= maxIterations, `process.exit(0)` (safety valve)
  6. If iteration >= maxIterations, `process.exit(0)`
  7. Read transcript_path, check if it contains completionPromise string -- if yes, `process.exit(0)`
  8. Otherwise: increment iteration, build continuation reason:
     - Base: "Ralph Loop iteration N/M. " + state.prompt
     - If notebookLmGuidance exists, append "\n\n## NotebookLM Guidance:\n" + guidance
  9. Write JSON to stdout: `{ "decision": "block", "reason": reason }`
  10. Do NOT call process.exit after writing stdout (let Node.js exit naturally)

  Handle errors gracefully -- any uncaught error should allow stop (exit 0) to prevent broken hook from blocking Claude permanently.

  Wrap entire logic in try/catch, catch exits 0.

  Import IterationTracker from './iteration-tracker.js' (note .js extension for ESM).
  </action>
  <verify>`npx tsc --noEmit src/execution/stop-hook.ts` compiles. Verify the script has a top-level try/catch safety net.</verify>
  <done>Stop hook reads stdin JSON, checks ralph state, blocks or allows stop with proper continuation prompt.</done>
</task>

</tasks>

<verification>
TypeScript compiles. Script has safety valve (max iterations + try/catch).
</verification>

<success_criteria>
Stop hook correctly intercepts Claude exit, enforces iteration limits, injects continuation prompts.
</success_criteria>

<output>
After completion, create `.planning/phases/05-gsd-ralph-integration/05-04-SUMMARY.md`
</output>
