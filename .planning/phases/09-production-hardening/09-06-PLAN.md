---
phase: 09-production-hardening
plan: 06
type: execute
wave: 3
depends_on: ["09-01", "09-02", "09-05"]
files_modified:
  - src/session/index.ts
  - src/session/manager.ts
  - src/session/progress.ts
  - src/session/cancellation.ts
  - src/session/state-store.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Active operations are tracked with progress percentage"
    - "Sessions can be cancelled gracefully via cancellation token"
    - "Session state persists across crashes for resumption"
    - "Multiple concurrent sessions are tracked independently"
  artifacts:
    - path: "src/session/manager.ts"
      provides: "Session lifecycle management"
      exports: ["SessionManager", "Session"]
    - path: "src/session/progress.ts"
      provides: "Progress tracking and updates"
      exports: ["ProgressTracker", "ProgressState"]
    - path: "src/session/cancellation.ts"
      provides: "Graceful cancellation support"
      exports: ["CancellationToken", "CancellationSource"]
    - path: "src/session/state-store.ts"
      provides: "Crash-resilient state persistence"
      exports: ["SessionStateStore"]
    - path: "src/session/index.ts"
      provides: "Barrel export for session module"
      exports: ["SessionManager", "ProgressTracker", "CancellationToken"]
  key_links:
    - from: "src/session/manager.ts"
      to: "src/session/state-store.ts"
      via: "session state persistence"
      pattern: "stateStore\\.save"
    - from: "src/session/manager.ts"
      to: ".msw/sessions/"
      via: "session state files"
      pattern: "sessions/"
---

<objective>
Implement session management with progress tracking, cancellation support, and crash resumption.

Purpose: Track active operations with visibility into progress, enable graceful cancellation, and persist session state for crash recovery.

Output: Complete session module (`src/session/`) with SessionManager, progress tracking, cancellation tokens, and state persistence.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-production-hardening/09-RESEARCH.md
@.planning/phases/09-production-hardening/09-01-SUMMARY.md
@.planning/phases/09-production-hardening/09-02-SUMMARY.md
@.planning/phases/09-production-hardening/09-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement cancellation tokens and progress tracking</name>
  <files>
    src/session/cancellation.ts
    src/session/progress.ts
  </files>
  <action>
Create `src/session/` directory with cancellation and progress utilities:

**src/session/cancellation.ts:**
```typescript
/**
 * Cancellation token for cooperative cancellation.
 * Operations check this token to determine if they should abort.
 */
export class CancellationToken {
  private _isCancelled = false;
  private _reason?: string;
  private readonly callbacks: Array<(reason?: string) => void> = [];

  /**
   * Check if cancellation has been requested.
   */
  get isCancelled(): boolean {
    return this._isCancelled;
  }

  /**
   * Get the cancellation reason if cancelled.
   */
  get reason(): string | undefined {
    return this._reason;
  }

  /**
   * Register a callback to be invoked when cancellation is requested.
   */
  onCancelled(callback: (reason?: string) => void): void {
    if (this._isCancelled) {
      // Already cancelled, invoke immediately
      callback(this._reason);
    } else {
      this.callbacks.push(callback);
    }
  }

  /**
   * Throw if cancellation has been requested.
   */
  throwIfCancelled(): void {
    if (this._isCancelled) {
      throw new CancellationError(this._reason);
    }
  }

  /**
   * Internal: Mark as cancelled (used by CancellationSource).
   */
  _cancel(reason?: string): void {
    if (this._isCancelled) return;

    this._isCancelled = true;
    this._reason = reason;

    for (const callback of this.callbacks) {
      try {
        callback(reason);
      } catch {
        // Ignore callback errors
      }
    }
  }
}

/**
 * Source that controls a CancellationToken.
 * The token is given to operations, the source is held by the controller.
 */
export class CancellationSource {
  private readonly _token: CancellationToken;

  constructor() {
    this._token = new CancellationToken();
  }

  /**
   * Get the cancellation token to pass to operations.
   */
  get token(): CancellationToken {
    return this._token;
  }

  /**
   * Request cancellation with optional reason.
   */
  cancel(reason?: string): void {
    this._token._cancel(reason);
  }

  /**
   * Check if already cancelled.
   */
  get isCancelled(): boolean {
    return this._token.isCancelled;
  }
}

/**
 * Error thrown when an operation is cancelled.
 */
export class CancellationError extends Error {
  constructor(reason?: string) {
    super(reason || "Operation was cancelled");
    this.name = "CancellationError";
  }
}

/**
 * Create a cancellation token that auto-cancels after timeout.
 */
export function createTimeoutToken(timeoutMs: number): CancellationSource {
  const source = new CancellationSource();
  setTimeout(() => {
    if (!source.isCancelled) {
      source.cancel(`Timeout after ${timeoutMs}ms`);
    }
  }, timeoutMs);
  return source;
}
```

**src/session/progress.ts:**
```typescript
export type ProgressStatus = "pending" | "running" | "completed" | "failed" | "cancelled";

export interface ProgressState {
  sessionId: string;
  operation: string;
  status: ProgressStatus;
  progress: number;       // 0-100
  currentStep?: string;
  totalSteps?: number;
  completedSteps?: number;
  startedAt: string;
  updatedAt: string;
  error?: string;
  eta?: string;           // Estimated time remaining (ISO)
}

export type ProgressCallback = (state: ProgressState) => void;

/**
 * Progress tracker for long-running operations.
 */
export class ProgressTracker {
  private state: ProgressState;
  private readonly callbacks: ProgressCallback[] = [];

  constructor(sessionId: string, operation: string) {
    this.state = {
      sessionId,
      operation,
      status: "pending",
      progress: 0,
      startedAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
  }

  /**
   * Register a callback for progress updates.
   */
  onProgress(callback: ProgressCallback): void {
    this.callbacks.push(callback);
  }

  /**
   * Start the operation.
   */
  start(totalSteps?: number): void {
    this.update({
      status: "running",
      totalSteps,
      completedSteps: 0,
    });
  }

  /**
   * Update progress percentage (0-100).
   */
  setProgress(progress: number, currentStep?: string): void {
    this.update({
      progress: Math.min(100, Math.max(0, progress)),
      currentStep,
    });
  }

  /**
   * Complete a step.
   */
  completeStep(stepName?: string): void {
    const completedSteps = (this.state.completedSteps || 0) + 1;
    const totalSteps = this.state.totalSteps || completedSteps;
    const progress = Math.round((completedSteps / totalSteps) * 100);

    this.update({
      completedSteps,
      progress,
      currentStep: stepName,
    });
  }

  /**
   * Mark operation as completed.
   */
  complete(): void {
    this.update({
      status: "completed",
      progress: 100,
    });
  }

  /**
   * Mark operation as failed.
   */
  fail(error: string): void {
    this.update({
      status: "failed",
      error,
    });
  }

  /**
   * Mark operation as cancelled.
   */
  cancel(reason?: string): void {
    this.update({
      status: "cancelled",
      error: reason || "Cancelled by user",
    });
  }

  /**
   * Set estimated time of completion.
   */
  setEta(eta: Date): void {
    this.update({
      eta: eta.toISOString(),
    });
  }

  /**
   * Get current state.
   */
  getState(): ProgressState {
    return { ...this.state };
  }

  /**
   * Check if operation is still running.
   */
  isRunning(): boolean {
    return this.state.status === "running";
  }

  private update(partial: Partial<ProgressState>): void {
    this.state = {
      ...this.state,
      ...partial,
      updatedAt: new Date().toISOString(),
    };

    for (const callback of this.callbacks) {
      try {
        callback(this.state);
      } catch {
        // Ignore callback errors
      }
    }
  }
}

/**
 * Format progress state for display.
 */
export function formatProgress(state: ProgressState): string {
  const bar = createProgressBar(state.progress, 30);
  const step = state.currentStep ? ` - ${state.currentStep}` : "";

  return `[${bar}] ${state.progress}% ${state.operation}${step}`;
}

function createProgressBar(percent: number, width: number): string {
  const filled = Math.round((percent / 100) * width);
  return "#".repeat(filled) + "-".repeat(width - filled);
}
```
  </action>
  <verify>
- `npx tsc --noEmit` passes
- Files exist at `src/session/cancellation.ts` and `src/session/progress.ts`
  </verify>
  <done>Cancellation tokens and progress tracking implemented</done>
</task>

<task type="auto">
  <name>Task 2: Implement session manager with crash resumption</name>
  <files>
    src/session/state-store.ts
    src/session/manager.ts
    src/session/index.ts
  </files>
  <action>
**src/session/state-store.ts:**
```typescript
import {
  existsSync,
  mkdirSync,
  readFileSync,
  writeFileSync,
  readdirSync,
  unlinkSync,
} from "node:fs";
import { join, dirname } from "node:path";
import type { ProgressState } from "./progress.js";

export interface SessionState {
  id: string;
  operation: string;
  status: "active" | "completed" | "failed" | "crashed";
  progress: ProgressState;
  context: Record<string, unknown>;  // Operation-specific data for resumption
  createdAt: string;
  updatedAt: string;
  crashedAt?: string;
}

/**
 * Persistent storage for session state (crash resumption).
 */
export class SessionStateStore {
  private readonly baseDir: string;

  constructor(basePath: string = process.cwd()) {
    this.baseDir = join(basePath, ".msw/sessions");
  }

  /**
   * Save session state to disk.
   */
  save(state: SessionState): void {
    if (!existsSync(this.baseDir)) {
      mkdirSync(this.baseDir, { recursive: true });
    }

    const filePath = this.getFilePath(state.id);
    writeFileSync(filePath, JSON.stringify(state, null, 2));
  }

  /**
   * Load session state from disk.
   */
  load(sessionId: string): SessionState | undefined {
    const filePath = this.getFilePath(sessionId);

    if (!existsSync(filePath)) {
      return undefined;
    }

    try {
      return JSON.parse(readFileSync(filePath, "utf-8")) as SessionState;
    } catch {
      return undefined;
    }
  }

  /**
   * Remove session state file.
   */
  remove(sessionId: string): boolean {
    const filePath = this.getFilePath(sessionId);

    if (!existsSync(filePath)) {
      return false;
    }

    try {
      unlinkSync(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * List all session IDs.
   */
  listSessions(): string[] {
    if (!existsSync(this.baseDir)) {
      return [];
    }

    return readdirSync(this.baseDir)
      .filter((f) => f.endsWith(".json"))
      .map((f) => f.replace(".json", ""));
  }

  /**
   * Find sessions that appear to have crashed (active but stale).
   */
  findCrashedSessions(staleThresholdMs: number = 60000): SessionState[] {
    const sessions: SessionState[] = [];
    const now = Date.now();

    for (const id of this.listSessions()) {
      const state = this.load(id);
      if (!state) continue;

      if (state.status === "active") {
        const updatedAt = new Date(state.updatedAt).getTime();
        if (now - updatedAt > staleThresholdMs) {
          sessions.push({
            ...state,
            status: "crashed",
            crashedAt: new Date().toISOString(),
          });
        }
      }
    }

    return sessions;
  }

  /**
   * Clean up old completed/failed sessions.
   */
  cleanup(maxAgeDays: number = 7): number {
    const maxAgeMs = maxAgeDays * 24 * 60 * 60 * 1000;
    const now = Date.now();
    let removed = 0;

    for (const id of this.listSessions()) {
      const state = this.load(id);
      if (!state) continue;

      // Only clean up non-active sessions
      if (state.status !== "active") {
        const updatedAt = new Date(state.updatedAt).getTime();
        if (now - updatedAt > maxAgeMs) {
          if (this.remove(id)) {
            removed++;
          }
        }
      }
    }

    return removed;
  }

  private getFilePath(sessionId: string): string {
    return join(this.baseDir, `${sessionId}.json`);
  }
}
```

**src/session/manager.ts:**
```typescript
import { randomUUID } from "node:crypto";
import { CancellationSource, CancellationToken } from "./cancellation.js";
import { ProgressTracker, type ProgressState, type ProgressCallback } from "./progress.js";
import { SessionStateStore, type SessionState } from "./state-store.js";

export interface Session {
  id: string;
  operation: string;
  progress: ProgressTracker;
  cancellation: CancellationSource;
  context: Record<string, unknown>;
  createdAt: Date;
}

export interface SessionManagerOptions {
  basePath?: string;
  autoSaveIntervalMs?: number;  // How often to persist state
}

/**
 * Session manager for tracking active operations.
 */
export class SessionManager {
  private readonly sessions: Map<string, Session> = new Map();
  private readonly stateStore: SessionStateStore;
  private readonly autoSaveInterval: number;
  private saveTimer?: ReturnType<typeof setInterval>;
  private readonly progressCallbacks: ProgressCallback[] = [];

  constructor(options: SessionManagerOptions = {}) {
    this.stateStore = new SessionStateStore(options.basePath);
    this.autoSaveInterval = options.autoSaveIntervalMs ?? 5000;
  }

  /**
   * Start auto-saving session state.
   */
  startAutoSave(): void {
    if (this.saveTimer) return;

    this.saveTimer = setInterval(() => {
      this.saveAllSessions();
    }, this.autoSaveInterval);
  }

  /**
   * Stop auto-saving session state.
   */
  stopAutoSave(): void {
    if (this.saveTimer) {
      clearInterval(this.saveTimer);
      this.saveTimer = undefined;
    }
  }

  /**
   * Create and start a new session.
   */
  createSession(operation: string, context: Record<string, unknown> = {}): Session {
    const id = randomUUID();
    const session: Session = {
      id,
      operation,
      progress: new ProgressTracker(id, operation),
      cancellation: new CancellationSource(),
      context,
      createdAt: new Date(),
    };

    // Register progress callback to notify global listeners
    session.progress.onProgress((state) => {
      this.notifyProgress(state);
      this.saveSession(session);
    });

    this.sessions.set(id, session);
    this.saveSession(session);

    return session;
  }

  /**
   * Get a session by ID.
   */
  getSession(id: string): Session | undefined {
    return this.sessions.get(id);
  }

  /**
   * Get all active sessions.
   */
  getActiveSessions(): Session[] {
    return Array.from(this.sessions.values()).filter(
      (s) => s.progress.isRunning()
    );
  }

  /**
   * Get all sessions (including completed).
   */
  getAllSessions(): Session[] {
    return Array.from(this.sessions.values());
  }

  /**
   * Cancel a session.
   */
  cancelSession(id: string, reason?: string): boolean {
    const session = this.sessions.get(id);
    if (!session) return false;

    session.cancellation.cancel(reason);
    session.progress.cancel(reason);
    this.saveSession(session);

    return true;
  }

  /**
   * Complete a session.
   */
  completeSession(id: string): boolean {
    const session = this.sessions.get(id);
    if (!session) return false;

    session.progress.complete();
    this.saveSession(session);
    this.sessions.delete(id);

    return true;
  }

  /**
   * Fail a session.
   */
  failSession(id: string, error: string): boolean {
    const session = this.sessions.get(id);
    if (!session) return false;

    session.progress.fail(error);
    this.saveSession(session);
    this.sessions.delete(id);

    return true;
  }

  /**
   * Register callback for progress updates from any session.
   */
  onProgress(callback: ProgressCallback): void {
    this.progressCallbacks.push(callback);
  }

  /**
   * Find sessions that crashed (for resumption).
   */
  findCrashedSessions(): SessionState[] {
    return this.stateStore.findCrashedSessions();
  }

  /**
   * Resume a crashed session.
   */
  resumeSession(crashedState: SessionState): Session | undefined {
    // Create new session with same ID and context
    const session: Session = {
      id: crashedState.id,
      operation: crashedState.operation,
      progress: new ProgressTracker(crashedState.id, crashedState.operation),
      cancellation: new CancellationSource(),
      context: crashedState.context,
      createdAt: new Date(crashedState.createdAt),
    };

    // Restore progress state
    session.progress.start(crashedState.progress.totalSteps);
    session.progress.setProgress(
      crashedState.progress.progress,
      crashedState.progress.currentStep
    );

    // Register progress callback
    session.progress.onProgress((state) => {
      this.notifyProgress(state);
      this.saveSession(session);
    });

    this.sessions.set(session.id, session);
    return session;
  }

  /**
   * Clean up old session state files.
   */
  cleanup(maxAgeDays?: number): number {
    return this.stateStore.cleanup(maxAgeDays);
  }

  /**
   * Save all sessions to disk.
   */
  saveAllSessions(): void {
    for (const session of this.sessions.values()) {
      this.saveSession(session);
    }
  }

  /**
   * Shutdown: stop auto-save and save all sessions.
   */
  shutdown(): void {
    this.stopAutoSave();
    this.saveAllSessions();
  }

  private saveSession(session: Session): void {
    const state: SessionState = {
      id: session.id,
      operation: session.operation,
      status: session.progress.isRunning() ? "active" : "completed",
      progress: session.progress.getState(),
      context: session.context,
      createdAt: session.createdAt.toISOString(),
      updatedAt: new Date().toISOString(),
    };

    this.stateStore.save(state);
  }

  private notifyProgress(state: ProgressState): void {
    for (const callback of this.progressCallbacks) {
      try {
        callback(state);
      } catch {
        // Ignore callback errors
      }
    }
  }
}

// Singleton instance
let globalManager: SessionManager | undefined;

/**
 * Get the global session manager instance.
 */
export function getSessionManager(): SessionManager {
  if (!globalManager) {
    globalManager = new SessionManager();
  }
  return globalManager;
}
```

**src/session/index.ts:**
```typescript
// Barrel export for session module
export {
  CancellationToken,
  CancellationSource,
  CancellationError,
  createTimeoutToken,
} from "./cancellation.js";

export {
  ProgressTracker,
  formatProgress,
  type ProgressState,
  type ProgressStatus,
  type ProgressCallback,
} from "./progress.js";

export {
  SessionStateStore,
  type SessionState,
} from "./state-store.js";

export {
  SessionManager,
  getSessionManager,
  type Session,
  type SessionManagerOptions,
} from "./manager.js";
```
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `ls src/session/` shows 5 files
- Test: Create session, update progress, verify state persists to .msw/sessions/
  </verify>
  <done>
- SessionManager tracks active operations with progress
- Cancellation tokens enable cooperative cancellation
- Session state persists to .msw/sessions/ for crash resumption
- findCrashedSessions() identifies interrupted operations
- resumeSession() restores session from crashed state
  </done>
</task>

</tasks>

<verification>
After completion:
1. Run `npx tsc --noEmit` - should pass without errors
2. Test session lifecycle:
   - Create session
   - Update progress
   - Verify .msw/sessions/{id}.json exists
   - Complete session
3. Test cancellation: Create session, cancel it, verify status is "cancelled"
4. Test crash resumption: Create session, simulate crash, call findCrashedSessions()
</verification>

<success_criteria>
- src/session/ module exports SessionManager, ProgressTracker, CancellationToken
- Active sessions tracked with progress percentage (0-100)
- Cancellation tokens enable graceful abort
- Session state persists to .msw/sessions/
- Crashed sessions can be detected and resumed
- Auto-save ensures state survives crashes
</success_criteria>

<output>
After completion, create `.planning/phases/09-production-hardening/09-06-SUMMARY.md`
</output>
