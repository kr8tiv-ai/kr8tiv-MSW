---
phase: 09-production-hardening
plan: 04
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/diagnostics/index.ts
  - src/diagnostics/health-checker.ts
  - src/diagnostics/chrome-profile.ts
  - src/diagnostics/selector-report.ts
  - src/diagnostics/auto-fixer.ts
autonomous: true

must_haves:
  truths:
    - "Chrome profile lock files are detected and auto-cleared"
    - "Selector failures generate diagnostic reports with suggestions"
    - "Health checks run before browser launch"
    - "Diagnostic reports are saved to .msw/diagnostics/"
  artifacts:
    - path: "src/diagnostics/chrome-profile.ts"
      provides: "Chrome lock file detection and clearing"
      exports: ["detectChromeLock", "clearChromeLock"]
    - path: "src/diagnostics/selector-report.ts"
      provides: "Selector failure diagnostic report generation"
      exports: ["createSelectorReport", "SelectorDiagnostic"]
    - path: "src/diagnostics/auto-fixer.ts"
      provides: "Automatic remediation handlers"
      exports: ["AutoFixer", "FixResult"]
    - path: "src/diagnostics/health-checker.ts"
      provides: "Pre-launch health validation"
      exports: ["runHealthCheck", "HealthCheckResult"]
    - path: "src/diagnostics/index.ts"
      provides: "Barrel export for diagnostics module"
      exports: ["runHealthCheck", "AutoFixer"]
  key_links:
    - from: "src/diagnostics/auto-fixer.ts"
      to: "src/diagnostics/chrome-profile.ts"
      via: "Chrome lock remediation"
      pattern: "clearChromeLock"
    - from: "src/diagnostics/health-checker.ts"
      to: "src/diagnostics/auto-fixer.ts"
      via: "automatic fix execution"
      pattern: "autoFixer\\.fix"
---

<objective>
Implement self-healing diagnostics that detect and auto-fix common issues like Chrome profile locks and selector failures.

Purpose: Reduce manual intervention by automatically detecting issues (Chrome locks, stale selectors) and remediating when possible, with diagnostic reports when manual action is needed.

Output: Complete diagnostics module (`src/diagnostics/`) with health checker, Chrome lock detection, selector diagnostics, and auto-fix handlers.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-production-hardening/09-RESEARCH.md
@.planning/phases/09-production-hardening/09-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Chrome profile lock detection and clearing</name>
  <files>
    src/diagnostics/chrome-profile.ts
  </files>
  <action>
Create `src/diagnostics/` directory and implement Chrome lock detection:

**src/diagnostics/chrome-profile.ts:**
```typescript
import { existsSync, unlinkSync, statSync, readdirSync } from "node:fs";
import { join, basename } from "node:path";

/**
 * Chrome lock files that indicate a profile is in use.
 */
const CHROME_LOCK_FILES = [
  "SingletonLock",
  "SingletonSocket",
  "SingletonCookie",
];

/**
 * Database lock patterns that may persist after crashes.
 */
const DB_LOCK_PATTERNS = [
  "shared_proto_db/metadata/LOCK",
  "Local State.lock",
  "Cookies.lock",
  "History.lock",
];

export interface LockDetectionResult {
  profilePath: string;
  locksFound: string[];
  isLocked: boolean;
  lastModified?: Date;
}

export interface LockClearResult {
  cleared: string[];
  failed: string[];
  success: boolean;
}

/**
 * Detect Chrome profile lock files (HARD-13).
 */
export function detectChromeLock(profilePath: string): LockDetectionResult {
  const locksFound: string[] = [];
  let lastModified: Date | undefined;

  // Check main lock files
  for (const lockFile of CHROME_LOCK_FILES) {
    const lockPath = join(profilePath, lockFile);
    if (existsSync(lockPath)) {
      locksFound.push(lockFile);
      try {
        const stat = statSync(lockPath);
        if (!lastModified || stat.mtime > lastModified) {
          lastModified = stat.mtime;
        }
      } catch {
        // Ignore stat errors
      }
    }
  }

  // Check database lock patterns
  for (const pattern of DB_LOCK_PATTERNS) {
    const lockPath = join(profilePath, pattern);
    if (existsSync(lockPath)) {
      locksFound.push(pattern);
    }
  }

  return {
    profilePath,
    locksFound,
    isLocked: locksFound.length > 0,
    lastModified,
  };
}

/**
 * Clear Chrome profile lock files (HARD-13).
 * Only clears if the lock appears stale (no running Chrome process).
 */
export function clearChromeLock(profilePath: string): LockClearResult {
  const detection = detectChromeLock(profilePath);
  const cleared: string[] = [];
  const failed: string[] = [];

  if (!detection.isLocked) {
    return { cleared: [], failed: [], success: true };
  }

  // Attempt to clear each lock file
  for (const lockFile of detection.locksFound) {
    const lockPath = join(profilePath, lockFile);

    try {
      unlinkSync(lockPath);
      cleared.push(lockFile);
    } catch (error) {
      // File may be in use by running Chrome
      failed.push(lockFile);
    }
  }

  return {
    cleared,
    failed,
    success: failed.length === 0,
  };
}

/**
 * Check if Chrome is likely running by looking for recent lock file activity.
 */
export function isChromeRunning(profilePath: string): boolean {
  const detection = detectChromeLock(profilePath);

  if (!detection.isLocked || !detection.lastModified) {
    return false;
  }

  // If lock was modified in the last 5 seconds, Chrome is likely running
  const fiveSecondsAgo = new Date(Date.now() - 5000);
  return detection.lastModified > fiveSecondsAgo;
}

/**
 * Get safe message for lock state (for user display).
 */
export function getLockMessage(result: LockDetectionResult): string {
  if (!result.isLocked) {
    return "No lock files detected. Profile is available.";
  }

  const files = result.locksFound.join(", ");
  return `Lock files detected: ${files}. Chrome may be running or crashed.`;
}
```
  </action>
  <verify>
- `npx tsc --noEmit` passes
- File exists at `src/diagnostics/chrome-profile.ts`
  </verify>
  <done>Chrome lock detection and clearing implemented with stale lock handling</done>
</task>

<task type="auto">
  <name>Task 2: Implement selector diagnostic reports and auto-fixer</name>
  <files>
    src/diagnostics/selector-report.ts
    src/diagnostics/auto-fixer.ts
    src/diagnostics/health-checker.ts
    src/diagnostics/index.ts
  </files>
  <action>
**src/diagnostics/selector-report.ts:**
```typescript
import { writeFileSync, existsSync, mkdirSync } from "node:fs";
import { join, dirname } from "node:path";

export interface SelectorDiagnostic {
  timestamp: string;
  failedSelector: string;
  error: string;
  suggestions: string[];
  htmlSnapshot?: string;
  pageUrl?: string;
  reportPath: string;
}

/**
 * Create diagnostic report for selector failure (HARD-14).
 */
export function createSelectorReport(
  selector: string,
  error: Error,
  options: {
    pageHtml?: string;
    pageUrl?: string;
    basePath?: string;
  } = {}
): SelectorDiagnostic {
  const basePath = options.basePath || process.cwd();
  const timestamp = new Date().toISOString();
  const reportId = `selector-${Date.now()}`;
  const reportPath = join(basePath, `.msw/diagnostics/${reportId}.json`);

  const report: SelectorDiagnostic = {
    timestamp,
    failedSelector: selector,
    error: error.message,
    suggestions: analyzeSelector(selector),
    htmlSnapshot: options.pageHtml?.substring(0, 10000), // First 10KB
    pageUrl: options.pageUrl,
    reportPath,
  };

  // Ensure directory exists
  const dir = dirname(reportPath);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  // Write report
  writeFileSync(reportPath, JSON.stringify(report, null, 2));

  return report;
}

/**
 * Analyze selector and suggest alternatives (HARD-14).
 */
function analyzeSelector(selector: string): string[] {
  const suggestions: string[] = [];

  // aria-label selectors
  if (selector.includes("aria-label")) {
    suggestions.push(
      "aria-label may have changed - check NotebookLM UI for updated labels"
    );
    suggestions.push(
      "Try using role-based selector: [role='button'], [role='textbox']"
    );
  }

  // data-* attribute selectors
  if (selector.includes("data-")) {
    suggestions.push(
      "data-* attributes may be dynamically generated - use more stable selector"
    );
    suggestions.push(
      "Consider text content selector: text='Submit' or :has-text('Submit')"
    );
  }

  // CSS class selectors (likely to break)
  if (selector.includes("class=") || selector.match(/\.[a-z]+-[a-zA-Z0-9]+/)) {
    suggestions.push(
      "CSS class selectors are brittle - NotebookLM uses generated class names"
    );
    suggestions.push(
      "Prefer semantic selectors: role, aria-label, text content"
    );
  }

  // ID selectors
  if (selector.startsWith("#") || selector.includes("id=")) {
    suggestions.push(
      "ID selectors may be stable - verify ID hasn't changed"
    );
  }

  // XPath selectors
  if (selector.startsWith("//") || selector.startsWith("xpath=")) {
    suggestions.push(
      "XPath selectors can be fragile - consider CSS alternatives"
    );
  }

  // Generic timeout suggestions
  suggestions.push(
    "Increase timeout if element loads asynchronously"
  );
  suggestions.push(
    "Check if element is inside iframe or shadow DOM"
  );

  return suggestions;
}

/**
 * Format selector report for human-readable display.
 */
export function formatSelectorReport(report: SelectorDiagnostic): string {
  let output = `
=== Selector Diagnostic Report ===
Time: ${report.timestamp}
Selector: ${report.failedSelector}
Error: ${report.error}
${report.pageUrl ? `URL: ${report.pageUrl}` : ""}

Suggestions:
`;

  for (const suggestion of report.suggestions) {
    output += `  - ${suggestion}\n`;
  }

  output += `
Report saved to: ${report.reportPath}
`;

  return output;
}
```

**src/diagnostics/auto-fixer.ts:**
```typescript
import { clearChromeLock, detectChromeLock, isChromeRunning } from "./chrome-profile.js";
import { createSelectorReport, type SelectorDiagnostic } from "./selector-report.js";

export type FixType = "chrome-lock" | "selector" | "config";

export interface FixResult {
  type: FixType;
  success: boolean;
  message: string;
  details?: Record<string, unknown>;
}

export interface AutoFixerOptions {
  profilePath?: string;
  basePath?: string;
  autoFix?: boolean; // Default true
}

/**
 * Automatic remediation handler for common issues.
 */
export class AutoFixer {
  private readonly profilePath: string;
  private readonly basePath: string;
  private readonly autoFix: boolean;

  constructor(options: AutoFixerOptions = {}) {
    this.profilePath = options.profilePath || `${process.env.HOME || process.env.USERPROFILE}/.msw/chrome-profile`;
    this.basePath = options.basePath || process.cwd();
    this.autoFix = options.autoFix ?? true;
  }

  /**
   * Fix Chrome profile lock issues (HARD-13).
   */
  fixChromeLock(): FixResult {
    const detection = detectChromeLock(this.profilePath);

    if (!detection.isLocked) {
      return {
        type: "chrome-lock",
        success: true,
        message: "No Chrome lock issues detected",
      };
    }

    // Don't auto-fix if Chrome appears to be running
    if (isChromeRunning(this.profilePath)) {
      return {
        type: "chrome-lock",
        success: false,
        message: "Chrome appears to be running. Close Chrome and try again.",
        details: { locksFound: detection.locksFound },
      };
    }

    if (!this.autoFix) {
      return {
        type: "chrome-lock",
        success: false,
        message: `Lock files detected but auto-fix disabled: ${detection.locksFound.join(", ")}`,
        details: { locksFound: detection.locksFound },
      };
    }

    // Attempt auto-fix
    const clearResult = clearChromeLock(this.profilePath);

    if (clearResult.success) {
      return {
        type: "chrome-lock",
        success: true,
        message: `Auto-cleared lock files: ${clearResult.cleared.join(", ")}`,
        details: { cleared: clearResult.cleared },
      };
    }

    return {
      type: "chrome-lock",
      success: false,
      message: `Some locks could not be cleared: ${clearResult.failed.join(", ")}`,
      details: {
        cleared: clearResult.cleared,
        failed: clearResult.failed,
      },
    };
  }

  /**
   * Handle selector failure with diagnostic report (HARD-14).
   */
  handleSelectorFailure(
    selector: string,
    error: Error,
    pageHtml?: string,
    pageUrl?: string
  ): FixResult {
    const report = createSelectorReport(selector, error, {
      pageHtml,
      pageUrl,
      basePath: this.basePath,
    });

    return {
      type: "selector",
      success: false, // Selector failures require manual investigation
      message: `Selector failure reported. Diagnostic saved to ${report.reportPath}`,
      details: {
        selector,
        suggestions: report.suggestions,
        reportPath: report.reportPath,
      },
    };
  }

  /**
   * Run all fixes and return results.
   */
  runAllFixes(): FixResult[] {
    const results: FixResult[] = [];

    // Chrome lock fix
    results.push(this.fixChromeLock());

    return results;
  }
}
```

**src/diagnostics/health-checker.ts:**
```typescript
import { existsSync } from "node:fs";
import { AutoFixer, type FixResult } from "./auto-fixer.js";
import { detectChromeLock } from "./chrome-profile.js";

export type HealthStatus = "healthy" | "degraded" | "unhealthy";

export interface HealthCheckResult {
  status: HealthStatus;
  checks: HealthCheck[];
  fixes: FixResult[];
  canProceed: boolean;
}

export interface HealthCheck {
  name: string;
  passed: boolean;
  message: string;
}

export interface HealthCheckOptions {
  profilePath?: string;
  configPath?: string;
  autoFix?: boolean;
}

/**
 * Run pre-launch health checks with optional auto-fix.
 */
export async function runHealthCheck(
  options: HealthCheckOptions = {}
): Promise<HealthCheckResult> {
  const profilePath = options.profilePath || `${process.env.HOME || process.env.USERPROFILE}/.msw/chrome-profile`;
  const configPath = options.configPath || `${process.cwd()}/.msw/config.yaml`;
  const autoFix = options.autoFix ?? true;

  const checks: HealthCheck[] = [];
  const fixes: FixResult[] = [];

  // Check 1: Configuration exists
  const configExists = existsSync(configPath);
  checks.push({
    name: "Configuration",
    passed: configExists,
    message: configExists
      ? "Configuration file found"
      : "No configuration file. Run `msw setup` first.",
  });

  // Check 2: Profile directory exists
  const profileExists = existsSync(profilePath);
  checks.push({
    name: "Profile Directory",
    passed: profileExists,
    message: profileExists
      ? "Chrome profile directory exists"
      : "Profile directory will be created on first launch",
  });

  // Check 3: No Chrome lock (with auto-fix)
  const lockDetection = detectChromeLock(profilePath);
  let lockCheckPassed = !lockDetection.isLocked;

  if (lockDetection.isLocked && autoFix) {
    const fixer = new AutoFixer({ profilePath, autoFix: true });
    const fixResult = fixer.fixChromeLock();
    fixes.push(fixResult);
    lockCheckPassed = fixResult.success;
  }

  checks.push({
    name: "Chrome Profile Lock",
    passed: lockCheckPassed,
    message: lockCheckPassed
      ? "No profile locks detected"
      : `Lock files present: ${lockDetection.locksFound.join(", ")}`,
  });

  // Check 4: .msw directory writable
  const mswDir = `${process.cwd()}/.msw`;
  const mswDirExists = existsSync(mswDir);
  checks.push({
    name: "MSW Directory",
    passed: true, // Will be created if needed
    message: mswDirExists
      ? ".msw directory exists"
      : ".msw directory will be created",
  });

  // Determine overall status
  const failedCritical = checks.some(
    (c) => !c.passed && (c.name === "Configuration" || c.name === "Chrome Profile Lock")
  );

  const status: HealthStatus = failedCritical
    ? "unhealthy"
    : checks.every((c) => c.passed)
    ? "healthy"
    : "degraded";

  return {
    status,
    checks,
    fixes,
    canProceed: status !== "unhealthy",
  };
}

/**
 * Format health check result for display.
 */
export function formatHealthCheck(result: HealthCheckResult): string {
  const statusEmoji = {
    healthy: "[OK]",
    degraded: "[WARN]",
    unhealthy: "[FAIL]",
  };

  let output = `
=== MSW Health Check ===
Status: ${statusEmoji[result.status]} ${result.status.toUpperCase()}

Checks:
`;

  for (const check of result.checks) {
    const checkMark = check.passed ? "[+]" : "[-]";
    output += `  ${checkMark} ${check.name}: ${check.message}\n`;
  }

  if (result.fixes.length > 0) {
    output += "\nAuto-Fixes Applied:\n";
    for (const fix of result.fixes) {
      const fixMark = fix.success ? "[+]" : "[-]";
      output += `  ${fixMark} ${fix.type}: ${fix.message}\n`;
    }
  }

  output += `
Can Proceed: ${result.canProceed ? "Yes" : "No"}
`;

  return output;
}
```

**src/diagnostics/index.ts:**
```typescript
// Barrel export for diagnostics module
export {
  detectChromeLock,
  clearChromeLock,
  isChromeRunning,
  getLockMessage,
  type LockDetectionResult,
  type LockClearResult,
} from "./chrome-profile.js";

export {
  createSelectorReport,
  formatSelectorReport,
  type SelectorDiagnostic,
} from "./selector-report.js";

export {
  AutoFixer,
  type FixResult,
  type FixType,
  type AutoFixerOptions,
} from "./auto-fixer.js";

export {
  runHealthCheck,
  formatHealthCheck,
  type HealthCheckResult,
  type HealthCheck,
  type HealthStatus,
  type HealthCheckOptions,
} from "./health-checker.js";
```
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `ls src/diagnostics/` shows 5 files
- Test: Import and call `runHealthCheck()` - should return health status
  </verify>
  <done>
- Chrome profile lock detection and auto-clearing implemented
- Selector failure generates diagnostic report with suggestions
- Health checker validates system state before launch
- Auto-fixer remediates issues when possible
  </done>
</task>

</tasks>

<verification>
After completion:
1. Run `npx tsc --noEmit` - should pass without errors
2. Create a fake lock file and run health check - should detect and offer to clear
3. Create selector diagnostic report - should save to .msw/diagnostics/
4. Verify formatHealthCheck() produces readable output
</verification>

<success_criteria>
- src/diagnostics/ module exports runHealthCheck, AutoFixer
- Chrome lock files detected and auto-cleared when safe
- Selector failures generate reports in .msw/diagnostics/
- Health checker returns status with can/cannot proceed indicator
- All diagnostic reports include timestamps and suggestions
</success_criteria>

<output>
After completion, create `.planning/phases/09-production-hardening/09-04-SUMMARY.md`
</output>
