---
phase: 09-production-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/rate-limiting/index.ts
  - src/rate-limiting/quota-tracker.ts
  - src/rate-limiting/usage-store.ts
  - src/rate-limiting/dashboard.ts
autonomous: true

must_haves:
  truths:
    - "NotebookLM requests are tracked against 50 queries/day limit"
    - "Warning is displayed when 80% of quota is consumed"
    - "Usage persists across application restarts"
    - "Dashboard displays used/remaining/reset time"
  artifacts:
    - path: "src/rate-limiting/quota-tracker.ts"
      provides: "Request tracking with quota enforcement"
      exports: ["QuotaTracker", "QuotaUsage"]
    - path: "src/rate-limiting/usage-store.ts"
      provides: "Persistent JSON storage for quota state"
      exports: ["UsageStore"]
    - path: "src/rate-limiting/dashboard.ts"
      provides: "Terminal display of usage statistics"
      exports: ["displayUsageDashboard", "formatUsageStatus"]
    - path: "src/rate-limiting/index.ts"
      provides: "Barrel export for rate-limiting module"
      exports: ["QuotaTracker", "displayUsageDashboard"]
  key_links:
    - from: "src/rate-limiting/quota-tracker.ts"
      to: "src/rate-limiting/usage-store.ts"
      via: "persistence of quota state"
      pattern: "UsageStore"
    - from: "src/rate-limiting/quota-tracker.ts"
      to: ".msw/quota.json"
      via: "JSON file storage"
      pattern: "quota\\.json"
---

<objective>
Implement rate limiting handler with quota tracking for NotebookLM's 50 queries/day limit.

Purpose: Prevent exceeding NotebookLM's daily quota by tracking usage, warning at 80% threshold, and providing a dashboard to display remaining queries.

Output: Complete rate-limiting module (`src/rate-limiting/`) with QuotaTracker class, persistent storage, and usage dashboard display.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-production-hardening/09-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement persistent usage storage</name>
  <files>
    src/rate-limiting/usage-store.ts
  </files>
  <action>
Create `src/rate-limiting/` directory and implement UsageStore:

**src/rate-limiting/usage-store.ts:**
```typescript
import { readFileSync, writeFileSync, existsSync, mkdirSync } from "node:fs";
import { dirname, join } from "node:path";

export interface QuotaState {
  date: string;           // Current day (YYYY-MM-DD)
  used: number;           // Queries used today
  limit: number;          // Daily limit (50 for free, 500 for enterprise)
  lastReset: string;      // Last reset timestamp (ISO)
  history: DayUsage[];    // Last 7 days for analytics
}

interface DayUsage {
  date: string;
  used: number;
}

const DEFAULT_LIMIT = 50;
const HISTORY_DAYS = 7;

export class UsageStore {
  private readonly filePath: string;

  constructor(basePath: string = process.cwd()) {
    this.filePath = join(basePath, ".msw/quota.json");
  }

  load(): QuotaState {
    const today = new Date().toISOString().split("T")[0];

    if (existsSync(this.filePath)) {
      try {
        const saved = JSON.parse(readFileSync(this.filePath, "utf-8")) as QuotaState;

        // Reset if new day
        if (saved.date !== today) {
          // Archive previous day to history
          const history = this.archiveDay(saved);
          return this.createState(today, saved.limit, history);
        }
        return saved;
      } catch {
        // Corrupted file, start fresh
        return this.createState(today);
      }
    }

    return this.createState(today);
  }

  save(state: QuotaState): void {
    const dir = dirname(this.filePath);
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }
    writeFileSync(this.filePath, JSON.stringify(state, null, 2));
  }

  private createState(
    date: string,
    limit: number = DEFAULT_LIMIT,
    history: DayUsage[] = []
  ): QuotaState {
    return {
      date,
      used: 0,
      limit,
      lastReset: new Date().toISOString(),
      history,
    };
  }

  private archiveDay(state: QuotaState): DayUsage[] {
    const history = [...(state.history || [])];

    // Add previous day to history
    if (state.used > 0) {
      history.unshift({ date: state.date, used: state.used });
    }

    // Keep only last N days
    return history.slice(0, HISTORY_DAYS);
  }

  /**
   * Update the daily limit (for enterprise accounts).
   */
  setLimit(limit: number): void {
    const state = this.load();
    state.limit = limit;
    this.save(state);
  }

  getFilePath(): string {
    return this.filePath;
  }
}
```
  </action>
  <verify>
- `npx tsc --noEmit` passes
- File exists at `src/rate-limiting/usage-store.ts`
  </verify>
  <done>UsageStore provides persistent JSON storage for quota state with daily reset</done>
</task>

<task type="auto">
  <name>Task 2: Implement QuotaTracker with warning threshold</name>
  <files>
    src/rate-limiting/quota-tracker.ts
    src/rate-limiting/dashboard.ts
    src/rate-limiting/index.ts
  </files>
  <action>
**src/rate-limiting/quota-tracker.ts:**
```typescript
import { UsageStore, type QuotaState } from "./usage-store.js";

const WARNING_THRESHOLD = 0.8; // 80% (HARD-09)

export interface QuotaUsage {
  used: number;
  limit: number;
  remaining: number;
  percentUsed: number;
  resetTime: string;
  isWarning: boolean;
  isExhausted: boolean;
}

export interface QuotaCheckResult {
  allowed: boolean;
  warning?: string;
  usage: QuotaUsage;
}

export class QuotaTracker {
  private state: QuotaState;
  private store: UsageStore;

  constructor(basePath?: string) {
    this.store = new UsageStore(basePath);
    this.state = this.store.load();
  }

  /**
   * Check if a request can proceed. Returns status with warning if approaching limit.
   * HARD-09: Warns at 80% quota threshold.
   */
  canRequest(): QuotaCheckResult {
    // Reload state in case of date change
    this.state = this.store.load();
    const usage = this.getUsage();

    if (usage.isExhausted) {
      return {
        allowed: false,
        warning: `Daily quota exhausted (${usage.used}/${usage.limit}). Resets at ${this.formatResetTime(usage.resetTime)}.`,
        usage,
      };
    }

    if (usage.isWarning) {
      return {
        allowed: true,
        warning: `Approaching quota limit: ${usage.remaining} requests remaining today.`,
        usage,
      };
    }

    return { allowed: true, usage };
  }

  /**
   * Record that a request was made. Call AFTER successful request.
   */
  recordRequest(): void {
    this.state.used++;
    this.store.save(this.state);
  }

  /**
   * Get current usage statistics (HARD-10: for dashboard display).
   */
  getUsage(): QuotaUsage {
    const resetTime = this.calculateResetTime();
    const percentUsed = Math.round((this.state.used / this.state.limit) * 100);

    return {
      used: this.state.used,
      limit: this.state.limit,
      remaining: Math.max(0, this.state.limit - this.state.used),
      percentUsed,
      resetTime: resetTime.toISOString(),
      isWarning: percentUsed >= WARNING_THRESHOLD * 100,
      isExhausted: this.state.used >= this.state.limit,
    };
  }

  /**
   * Get usage history for analytics.
   */
  getHistory(): Array<{ date: string; used: number }> {
    return [
      { date: this.state.date, used: this.state.used },
      ...(this.state.history || []),
    ];
  }

  /**
   * Update daily limit (for enterprise accounts).
   */
  setLimit(limit: number): void {
    this.state.limit = limit;
    this.store.save(this.state);
  }

  private calculateResetTime(): Date {
    const resetTime = new Date(this.state.date);
    resetTime.setDate(resetTime.getDate() + 1);
    resetTime.setHours(0, 0, 0, 0);
    return resetTime;
  }

  private formatResetTime(isoTime: string): string {
    const date = new Date(isoTime);
    return date.toLocaleTimeString(undefined, {
      hour: "2-digit",
      minute: "2-digit",
    });
  }
}
```

**src/rate-limiting/dashboard.ts:**
```typescript
import type { QuotaUsage } from "./quota-tracker.js";

/**
 * Format usage status as a single-line string for logs/CLI.
 */
export function formatUsageStatus(usage: QuotaUsage): string {
  const bar = createProgressBar(usage.percentUsed, 20);
  const status = usage.isExhausted
    ? "EXHAUSTED"
    : usage.isWarning
    ? "WARNING"
    : "OK";

  return `[${bar}] ${usage.used}/${usage.limit} (${usage.remaining} remaining) [${status}]`;
}

/**
 * Display full usage dashboard to console (HARD-10).
 */
export function displayUsageDashboard(usage: QuotaUsage): void {
  const bar = createProgressBar(usage.percentUsed, 40);
  const resetDate = new Date(usage.resetTime);

  console.error(""); // Use stderr for MCP safety
  console.error("=== NotebookLM Quota Dashboard ===");
  console.error("");
  console.error(`  Requests Used:  ${usage.used}/${usage.limit}`);
  console.error(`  Remaining:      ${usage.remaining}`);
  console.error(`  Usage:          [${bar}] ${usage.percentUsed}%`);
  console.error(`  Resets At:      ${resetDate.toLocaleString()}`);
  console.error("");

  if (usage.isExhausted) {
    console.error("  STATUS: EXHAUSTED - Wait for reset or upgrade account");
  } else if (usage.isWarning) {
    console.error("  STATUS: WARNING - Consider batching remaining queries");
  } else {
    console.error("  STATUS: OK");
  }

  console.error("");
  console.error("=================================");
  console.error("");
}

/**
 * Create ASCII progress bar.
 */
function createProgressBar(percent: number, width: number): string {
  const filled = Math.round((percent / 100) * width);
  const empty = width - filled;
  const fillChar = percent >= 80 ? "!" : "#";
  return fillChar.repeat(filled) + "-".repeat(empty);
}

/**
 * Format usage as JSON for structured output.
 */
export function formatUsageJson(usage: QuotaUsage): string {
  return JSON.stringify(usage, null, 2);
}
```

**src/rate-limiting/index.ts:**
```typescript
// Barrel export for rate-limiting module
export { QuotaTracker, type QuotaUsage, type QuotaCheckResult } from "./quota-tracker.js";
export { UsageStore, type QuotaState } from "./usage-store.js";
export {
  displayUsageDashboard,
  formatUsageStatus,
  formatUsageJson,
} from "./dashboard.js";
```
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `ls src/rate-limiting/` shows 4 files
- Test: Create a simple script that instantiates QuotaTracker and calls canRequest() - should return usage stats
  </verify>
  <done>
- QuotaTracker tracks requests against configurable limit (default 50)
- Warning at 80% threshold, blocked at 100%
- Usage persists to .msw/quota.json and survives restarts
- Dashboard displays formatted usage with progress bar
  </done>
</task>

</tasks>

<verification>
After completion:
1. Run `npx tsc --noEmit` - should pass without errors
2. Manually test QuotaTracker:
   - Create instance, call `recordRequest()` several times
   - Check `.msw/quota.json` persists count
   - Restart node, verify count is preserved
3. Test 80% warning: Set limit to 10, record 8 requests, verify warning message
</verification>

<success_criteria>
- QuotaTracker class exported from src/rate-limiting/
- .msw/quota.json persists usage across restarts
- canRequest() returns warning at 80% threshold
- Dashboard displays used/remaining/reset in formatted output
- Works with default 50 limit and configurable enterprise limits
</success_criteria>

<output>
After completion, create `.planning/phases/09-production-hardening/09-02-SUMMARY.md`
</output>
