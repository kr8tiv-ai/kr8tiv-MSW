---
phase: 04-mcp-server
plan: 04
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/mcp/tools/msw-research.ts
autonomous: true

must_haves:
  truths:
    - "msw_research returns a job ID immediately without blocking"
    - "Research job drives the auto-conversation engine in background"
  artifacts:
    - path: "src/mcp/tools/msw-research.ts"
      provides: "msw_research tool registrar"
      exports: ["registerMswResearch"]
  key_links:
    - from: "src/mcp/tools/msw-research.ts"
      to: "src/mcp/jobs/job-manager.ts"
      via: "creates job, updates on completion/failure"
      pattern: "jobManager\\.create|jobManager\\.update"
    - from: "src/mcp/tools/msw-research.ts"
      to: "src/auto-conversation/"
      via: "imports ConversationEngine to run extraction"
      pattern: "ConversationEngine|runResearch"
---

<objective>
Implement msw_research tool (MCP-03) that triggers NotebookLM extraction as a long-running job.

Purpose: This is the primary research tool — it kicks off the auto-conversation engine to explore NotebookLM topics and extract Q&A. Returns a job ID for polling via msw_status.
Output: msw_research tool registrar with async job execution.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-mcp-server/04-RESEARCH.md
@.planning/phases/04-mcp-server/04-01-SUMMARY.md
@.planning/phases/04-mcp-server/04-02-SUMMARY.md
@src/auto-conversation/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: msw_research tool with job ID pattern</name>
  <files>src/mcp/tools/msw-research.ts</files>
  <action>
    Create `src/mcp/tools/msw-research.ts` exporting `registerMswResearch(server: McpServer)`:

    Register tool "msw_research" with description "Trigger NotebookLM research extraction (long-running, returns job ID)".

    Zod input schema:
    - projectDir: z.string().describe("Project directory with .msw/ config")
    - topic: z.string().describe("Research topic or question to explore")
    - maxQueries: z.number().optional().default(20).describe("Maximum queries before stopping")
    - relevanceThreshold: z.number().optional().default(60).describe("Minimum relevance score 0-100")

    Handler logic:
    1. Validate .msw/config.json exists in projectDir (return isError if not initialized)
    2. Read config to get notebookUrls
    3. Create job via jobManager.create("msw_research")
    4. Return immediately with { jobId, status: "queued", pollWith: "msw_status" }
    5. Fire-and-forget: call `runResearchJob(jobId, projectDir, topic, options)` async

    The `runResearchJob` function (private, same file):
    1. Update job status to "running"
    2. Import and call ConversationEngine from src/auto-conversation (or stub if not yet available — use try/catch import)
    3. On progress: update job.progress with { step, total, message }
    4. On completion: update job status to "completed", set job.result
    5. On error: update job status to "failed", set job.error

    IMPORTANT: If auto-conversation engine is not yet available at runtime, catch the import error and set job result to a stub message indicating the engine needs Phase 2 completion. This allows the MCP server to work standalone.
  </action>
  <verify>`npx tsc --noEmit src/mcp/tools/msw-research.ts`</verify>
  <done>msw_research creates a background job and returns job ID immediately</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. Tool returns job ID without blocking
3. Job status transitions through queued -> running -> completed/failed
</verification>

<success_criteria>
msw_research triggers long-running research and returns a pollable job ID.
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-server/04-04-SUMMARY.md`
</output>
