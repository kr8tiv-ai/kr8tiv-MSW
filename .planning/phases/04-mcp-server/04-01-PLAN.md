---
phase: 04-mcp-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcp/server.ts
  - src/mcp/index.ts
autonomous: true

must_haves:
  truths:
    - "MCP server starts on stdio transport without errors"
    - "Server responds to initialize and tools/list requests"
  artifacts:
    - path: "src/mcp/server.ts"
      provides: "McpServer instance creation and transport setup"
      exports: ["createServer"]
    - path: "src/mcp/index.ts"
      provides: "Binary entry point with shebang"
      contains: "#!/usr/bin/env node"
  key_links:
    - from: "src/mcp/index.ts"
      to: "src/mcp/server.ts"
      via: "imports createServer and connects transport"
      pattern: "createServer.*connect"
---

<objective>
Scaffold the MCP server with stdio transport using `@modelcontextprotocol/sdk` McpServer class.

Purpose: Establishes the MCP server process that all tools will be registered on. This is the foundation every other plan depends on.
Output: A runnable `src/mcp/index.ts` entry point that starts an MCP server on stdio and responds to tool discovery.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mcp-server/04-RESEARCH.md
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install MCP SDK and create server module</name>
  <files>package.json, src/mcp/server.ts</files>
  <action>
    Run `npm install @modelcontextprotocol/sdk` to add the MCP SDK.

    Create `src/mcp/server.ts` exporting a `createServer()` function that:
    1. Instantiates `McpServer` from `@modelcontextprotocol/sdk/server/mcp.js` with name "msw-protocol" and version from package.json
    2. Returns the server instance (tools will be registered by other modules)

    Use the high-level `McpServer` class, NOT the low-level `Server` class. Import pattern:
    ```typescript
    import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
    import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
    ```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/mcp/server.ts`</verify>
  <done>server.ts exports createServer() returning a configured McpServer instance</done>
</task>

<task type="auto">
  <name>Task 2: Create binary entry point with stdio transport</name>
  <files>src/mcp/index.ts, package.json</files>
  <action>
    Create `src/mcp/index.ts` as the entry point:
    1. Add `#!/usr/bin/env node` shebang comment at top
    2. Import createServer from `./server.js`
    3. Create server, create `StdioServerTransport`, call `server.connect(transport)`
    4. Log startup message to `console.error` (NOT console.log â€” stdout is MCP transport)
    5. Add unhandled rejection handler that logs to stderr

    Update package.json to add bin entry:
    ```json
    "bin": { "msw-mcp-server": "./dist/mcp/index.js" }
    ```

    CRITICAL: No console.log anywhere in MCP code. All logging to console.error (stderr). stdout is the JSON-RPC channel.
  </action>
  <verify>Run `npx tsc` to build, then `node dist/mcp/index.js` should start without crashing (it will wait for stdin input). Kill with Ctrl+C after confirming no errors on stderr besides the startup message.</verify>
  <done>Entry point starts MCP server on stdio, logs to stderr only, bin entry in package.json</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. `node dist/mcp/index.js` starts and prints startup message to stderr
3. No console.log calls in any mcp/ file (grep confirms)
</verification>

<success_criteria>
MCP server process starts on stdio transport and is ready for tool registration.
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-server/04-01-SUMMARY.md`
</output>
