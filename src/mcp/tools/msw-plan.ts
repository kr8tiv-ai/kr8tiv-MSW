import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { readdir, readFile, writeFile, mkdir, access } from "node:fs/promises";
import { join, dirname } from "node:path";
import { jobManager } from "../jobs/job-manager.js";
import type { ToolResult } from "../jobs/types.js";

export function registerMswPlan(server: McpServer): void {
  server.tool(
    "msw_plan",
    "Generate PRD from research findings (long-running, returns job ID)",
    {
      projectDir: z.string().describe("Project directory with .msw/ config and research data"),
      researchJobId: z.string().optional().describe("Job ID of completed research to use"),
      outputPath: z.string().optional().describe("Path for generated PRD (default: .msw/PRD.md)"),
    },
    async ({ projectDir, researchJobId, outputPath }): Promise<ToolResult> => {
      const mswDir = join(projectDir, ".msw");

      try {
        await access(mswDir);
      } catch {
        return {
          content: [{ type: "text", text: `Error: .msw/ directory not found in ${projectDir}` }],
          isError: true,
        };
      }

      if (researchJobId) {
        const researchJob = jobManager.get(researchJobId);
        if (!researchJob) {
          return {
            content: [{ type: "text", text: `Error: research job ${researchJobId} not found` }],
            isError: true,
          };
        }
        if (researchJob.status !== "completed") {
          return {
            content: [{ type: "text", text: `Error: research job ${researchJobId} status is ${researchJob.status}, expected completed` }],
            isError: true,
          };
        }
      }

      const job = jobManager.create("msw_plan");
      const prdPath = outputPath ?? join(mswDir, "PRD.md");

      // Run in background
      void (async () => {
        try {
          jobManager.update(job.id, { status: "running" });

          // Step 1: Read research files
          const researchDir = join(mswDir, "research");
          let researchFiles: string[] = [];
          try {
            const entries = await readdir(researchDir);
            researchFiles = entries.filter((f) => f.endsWith(".md") || f.endsWith(".txt"));
          } catch {
            // No research directory - proceed with empty research
          }

          jobManager.update(job.id, {
            progress: { step: 1, total: 3, message: `Found ${researchFiles.length} research files` },
          });

          // Step 2: Compile research content
          const sections: string[] = [];
          for (const file of researchFiles) {
            const content = await readFile(join(researchDir, file), "utf-8");
            sections.push(`## ${file}\n\n${content}`);
          }

          jobManager.update(job.id, {
            progress: { step: 2, total: 3, message: "Compiling PRD" },
          });

          // Step 3: Generate PRD (stub - Phase 5 will add real generation)
          const prd = [
            "# Product Requirements Document",
            "",
            `Generated: ${new Date().toISOString()}`,
            "",
            "## Overview",
            "",
            researchFiles.length > 0
              ? "This PRD is compiled from the following research findings."
              : "No research data found. Populate .msw/research/ with findings.",
            "",
            ...sections,
            "",
            "---",
            "*Generated by MSW Protocol (stub - pending Phase 5 engine integration)*",
          ].join("\n");

          await mkdir(dirname(prdPath), { recursive: true }).catch(() => {});
          await writeFile(prdPath, prd, "utf-8");

          jobManager.update(job.id, {
            status: "completed",
            progress: { step: 3, total: 3, message: "PRD written" },
            result: { prdPath, researchFilesUsed: researchFiles.length },
          });
        } catch (err) {
          jobManager.update(job.id, {
            status: "failed",
            error: err instanceof Error ? err.message : String(err),
          });
        }
      })();

      return {
        content: [{ type: "text", text: JSON.stringify({ jobId: job.id, status: "queued" }) }],
      };
    },
  );
}
