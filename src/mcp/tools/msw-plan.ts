import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { readdir, readFile, writeFile, mkdir, access } from "node:fs/promises";
import { join, dirname } from "node:path";
import { jobManager } from "../jobs/job-manager.js";
import type { ToolResult } from "../jobs/types.js";
import { resolvePathWithinBase } from "../../common/path-guard.js";

export function registerMswPlan(server: McpServer): void {
  server.tool(
    "msw_plan",
    "Generate PRD from research findings (long-running, returns job ID)",
    {
      projectDir: z.string().describe("Project directory with .msw/ config and research data"),
      researchJobId: z.string().optional().describe("Job ID of completed research to use"),
      outputPath: z.string().optional().describe("Path for generated PRD (default: .msw/PRD.md)"),
      projectName: z.string().optional().default("MSW Project").describe("Project name for PRD header"),
      description: z.string().optional().default("").describe("Project description"),
      constraints: z.array(z.string()).optional().default([]).describe("Project constraints"),
      requirements: z.array(z.string()).optional().default([]).describe("Project requirements"),
    },
    async ({ projectDir, researchJobId, outputPath, projectName, description, constraints, requirements }): Promise<ToolResult> => {
      const mswDir = join(projectDir, ".msw");

      try {
        await access(mswDir);
      } catch {
        return {
          content: [{ type: "text", text: `Error: .msw/ directory not found in ${projectDir}` }],
          isError: true,
        };
      }

      if (researchJobId) {
        const researchJob = jobManager.get(researchJobId);
        if (!researchJob) {
          return {
            content: [{ type: "text", text: `Error: research job ${researchJobId} not found` }],
            isError: true,
          };
        }
        if (researchJob.status !== "completed") {
          return {
            content: [{ type: "text", text: `Error: research job ${researchJobId} status is ${researchJob.status}, expected completed` }],
            isError: true,
          };
        }
      }

      const requestedOutputPath = outputPath ?? join(mswDir, "PRD.md");
      const prdPath = resolvePathWithinBase(projectDir, requestedOutputPath);
      if (!prdPath) {
        return {
          content: [{ type: "text", text: "Error: outputPath must resolve inside the project directory" }],
          isError: true,
        };
      }

      const job = jobManager.create("msw_plan");

      // Run in background
      void (async () => {
        try {
          jobManager.update(job.id, { status: "running" });

          // Step 1: Read research files
          const researchDir = join(mswDir, "research");
          let researchFiles: string[] = [];
          try {
            const entries = await readdir(researchDir);
            researchFiles = entries.filter((f) => f.endsWith(".md") || f.endsWith(".txt"));
          } catch {
            // No research directory - proceed with empty research
          }

          jobManager.update(job.id, {
            progress: { step: 1, total: 3, message: `Found ${researchFiles.length} research files` },
          });

          jobManager.update(job.id, {
            progress: { step: 2, total: 3, message: "Generating PRD via PrdGenerator" },
          });

          // Step 2: Try real PrdGenerator, fall back to template
          let prd: string;
          try {
            const { generatePrd } = await import("../../planning/prd-generator.js");

            prd = generatePrd({
              projectName: projectName ?? "MSW Project",
              description: description ?? "",
              researchDir,
              constraints: constraints ?? [],
              requirements: requirements ?? [],
            });
          } catch {
            // Fallback: compile sections manually if PrdGenerator not available
            const sections: string[] = [];
            for (const file of researchFiles) {
              const content = await readFile(join(researchDir, file), "utf-8");
              sections.push(`## ${file}\n\n${content}`);
            }

            prd = [
              "# Product Requirements Document",
              "",
              `Generated: ${new Date().toISOString()}`,
              "",
              "## Overview",
              "",
              researchFiles.length > 0
                ? "This PRD is compiled from the following research findings."
                : "No research data found. Populate .msw/research/ with findings.",
              "",
              ...sections,
              "",
              "---",
              "*Generated by MSW Protocol (PrdGenerator unavailable, used fallback template)*",
            ].join("\n");
          }

          await mkdir(dirname(prdPath), { recursive: true }).catch(() => {});
          await writeFile(prdPath, prd, "utf-8");

          jobManager.update(job.id, {
            status: "completed",
            progress: { step: 3, total: 3, message: "PRD written" },
            result: { prdPath, researchFilesUsed: researchFiles.length },
          });
        } catch (err) {
          jobManager.update(job.id, {
            status: "failed",
            error: err instanceof Error ? err.message : String(err),
          });
        }
      })();

      return {
        content: [{ type: "text", text: JSON.stringify({ jobId: job.id, status: "queued" }) }],
      };
    },
  );
}
